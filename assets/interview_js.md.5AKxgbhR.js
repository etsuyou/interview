import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.B2xMVIVo.js";const o=JSON.parse('{"title":"JavaScript 面试题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/js.md","filePath":"interview/js.md","lastUpdated":1719234304000}'),l={name:"interview/js.md"},h=[n(`<h1 id="javascript-面试题" tabindex="-1">JavaScript 面试题 <a class="header-anchor" href="#javascript-面试题" aria-label="Permalink to &quot;JavaScript 面试题&quot;">​</a></h1><h2 id="_1-数组的一些-api-哪些能够改变原数组-哪些不能" tabindex="-1">1. 数组的一些 API，哪些能够改变原数组，哪些不能 <a class="header-anchor" href="#_1-数组的一些-api-哪些能够改变原数组-哪些不能" aria-label="Permalink to &quot;1. 数组的一些 API，哪些能够改变原数组，哪些不能&quot;">​</a></h2><h3 id="能够改变原数组的方法-原地修改" tabindex="-1">能够改变原数组的方法（原地修改）： <a class="header-anchor" href="#能够改变原数组的方法-原地修改" aria-label="Permalink to &quot;能够改变原数组的方法（原地修改）：&quot;">​</a></h3><ul><li><code>push(item1, item2, ...)</code>: 向数组末尾添加一个或多个元素，并返回新数组的长度。</li><li><code>pop()</code>: 移除并返回数组的最后一个元素。</li><li><code>shift()</code>: 移除并返回数组的第一个元素。</li><li><code>unshift(item1, item2, ...)</code>: 在数组的开头添加一个或多个元素，并返回新数组的长度。</li><li><code>splice(start, count, item1, ...)</code>: 从指定位置删除或替换元素，添加新元素，返回被删除的元素数组。</li><li><code>sort(compareFunction)</code>: 对数组进行排序，改变原数组。</li><li><code>reverse()</code>: 反转数组中的元素顺序，改变原数组。</li></ul><h3 id="不能改变原数组的方法-返回新数组或其他值" tabindex="-1">不能改变原数组的方法（返回新数组或其他值）： <a class="header-anchor" href="#不能改变原数组的方法-返回新数组或其他值" aria-label="Permalink to &quot;不能改变原数组的方法（返回新数组或其他值）：&quot;">​</a></h3><ul><li><code>concat(array1, array2, ...)</code>: 连接两个或多个数组，返回新数组。</li><li><code>join(separator)</code>: 将数组的元素连接成字符串，返回字符串。</li><li><code>slice(start, end)</code>: 返回一个从指定开始索引到结束索引（不包括结束索引）的新数组，不影响原数组。</li><li><code>filter(callback, thisArg)</code>: 根据回调函数的条件过滤数组元素，返回新数组。</li><li><code>map(callback, thisArg)</code>: 将数组的每个元素映射到新数组，返回新数组。</li><li><code>reduce(callback, initialValue)</code>: 对数组元素依次执行回调函数，返回累积结果。</li><li><code>every(callback, thisArg)</code>: 检查数组所有元素是否满足条件，返回布尔值。</li><li><code>some(callback, thisArg)</code>: 检查数组是否有元素满足条件，返回布尔值。</li><li><code>find(callback, thisArg)</code>: 查找数组第一个满足条件的元素，返回元素值。</li><li><code>indexOf(value, fromIndex)</code>: 查找数组中指定值的索引，返回索引值，如果不存在则返回 -1。</li></ul><p>需要注意的是，虽然这些方法在返回新数组或其他值时不会改变原数组，但如果原数组的元素是对象，新数组中的元素可能会共享相同的引用。在使用数组方法时，根据需求选择适当的方法来操作数组。</p><h2 id="_2-for-foreach-for-in-for-of-的区别" tabindex="-1">2. for, forEach，for...in...，for...of...的区别 <a class="header-anchor" href="#_2-for-foreach-for-in-for-of-的区别" aria-label="Permalink to &quot;2. for, forEach，for...in...，for...of...的区别&quot;">​</a></h2><h3 id="区别和适用场景" tabindex="-1">区别和适用场景： <a class="header-anchor" href="#区别和适用场景" aria-label="Permalink to &quot;区别和适用场景：&quot;">​</a></h3><ul><li><code>for</code> 循环是通用的循环结构，适用于任何需要指定循环次数的情况。</li><li><code>forEach</code> 主要用于遍历数组，不适用于遍历对象，不能使用 <code>return</code> 和 <code>break</code>。</li><li><code>for...in</code> 循环主要用于遍历对象的属性名，但不保证属性的遍历顺序（数组是有序的）。</li><li><code>for...of</code> 循环用于遍历可迭代对象的值，不适用于普通对象。</li></ul><p>在 JavaScript 中，有多种循环结构可以用来遍历数组、对象和其他可迭代对象。以下是 <code>for</code>、<code>forEach</code>、<code>for...in</code> 和 <code>for...of</code> 的区别和适用场景：</p><h3 id="_1-for-循环" tabindex="-1">1. <code>for</code> 循环 <a class="header-anchor" href="#_1-for-循环" aria-label="Permalink to &quot;1. \`for\` 循环&quot;">​</a></h3><p><code>for</code> 循环是最基本的循环结构，用于遍历数组或执行特定次数的循环。</p><p><strong>语法：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array[i]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>特点：</strong></p><ul><li>可以完全控制循环变量（如索引 <code>i</code>）。</li><li>适用于任何需要精确控制循环次数的场景。</li><li>可以使用 <code>break</code> 和 <code>continue</code> 控制循环。</li></ul><h3 id="_2-foreach-方法" tabindex="-1">2. <code>forEach</code> 方法 <a class="header-anchor" href="#_2-foreach-方法" aria-label="Permalink to &quot;2. \`forEach\` 方法&quot;">​</a></h3><p><code>forEach</code> 是数组的方法，用于遍历数组的每个元素。</p><p><strong>语法：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p><strong>特点：</strong></p><ul><li>只能用于数组。</li><li>不可中途跳出循环（不能使用 <code>break</code> 和 <code>continue</code>）。</li><li>回调函数可以访问当前元素、索引和整个数组。</li></ul><h3 id="_3-for-in-循环" tabindex="-1">3. <code>for...in</code> 循环 <a class="header-anchor" href="#_3-for-in-循环" aria-label="Permalink to &quot;3. \`for...in\` 循环&quot;">​</a></h3><p><code>for...in</code> 循环用于遍历对象的可枚举属性（包括继承的属性）。</p><p><strong>语法：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> object) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, object[key]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>特点：</strong></p><ul><li>主要用于遍历对象的属性。</li><li>会遍历对象的所有可枚举属性，包括继承的属性（不推荐用于数组）。</li><li>顺序不保证。</li></ul><h3 id="_4-for-of-循环" tabindex="-1">4. <code>for...of</code> 循环 <a class="header-anchor" href="#_4-for-of-循环" aria-label="Permalink to &quot;4. \`for...of\` 循环&quot;">​</a></h3><p><code>for...of</code> 循环用于遍历可迭代对象（如数组、字符串、<code>Map</code>、<code>Set</code> 等）。</p><p><strong>语法：</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>特点：</strong></p><ul><li>适用于可迭代对象。</li><li>不能直接用于普通对象（对象不是可迭代的）。</li><li>可以使用 <code>break</code> 和 <code>continue</code> 控制循环。</li></ul><h3 id="示例代码" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码" aria-label="Permalink to &quot;示例代码&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例数组和对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> object</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, c: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// for 循环</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;for:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, array[i]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// forEach 方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;forEach:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, element);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// for...in 循环</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> object) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasOwnProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;for...in:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, key, object[key]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// for...of 循环</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;for...of:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, element);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><strong><code>for</code></strong>：适用于需要精确控制循环次数的场景。</li><li><strong><code>forEach</code></strong>：适用于遍历数组的每个元素，不能中途跳出循环。</li><li><strong><code>for...in</code></strong>：适用于遍历对象的可枚举属性，不推荐用于数组。</li><li><strong><code>for...of</code></strong>：适用于遍历可迭代对象（如数组、字符串等）。</li></ul><p>需要注意的是，在使用 <code>for...in</code> 循环时，可能会遍历到对象的原型链上的属性，因此通常需要使用 <code>hasOwnProperty</code> 方法来过滤掉非自身属性。而 <code>for...of</code> 循环只会遍历对象自身的可迭代属性。在实际开发中，根据不同的需求和数据类型，选择合适的循环方式可以使代码更加清晰和高效。</p><h2 id="_3-url-的组成" tabindex="-1">3. URL 的组成 <a class="header-anchor" href="#_3-url-的组成" aria-label="Permalink to &quot;3. URL 的组成&quot;">​</a></h2><p>URL 是用于定位资源的地址，它由多个部分组成，用于指示资源的位置和访问方式。一个标准的 URL 通常包含以下几个组成部分：</p><ul><li><strong>协议</strong>：两台电脑要通信必须使用协议（例如 <code>http</code>、<code>https</code>、<code>ftp</code> 等）。</li><li><strong>域名（IP）</strong>：电脑的唯一标识，IP 地址不方便记忆和推广，产生了域名，电脑要连接互联网必须使用 IP。IP 地址的组成：四部分组成，每一部分的区间范围 0-255。</li><li><strong>端口（Port）</strong>：端口部分指定了资源所在服务器上的端口号。如果省略，默认使用协议的默认端口，例如，80（HTTP）或 443（HTTPS）。</li><li><strong>路径（Path）</strong>：路径部分指定了服务器上资源的具体路径。它以斜杠 <code>/</code> 开头，可以包含多个目录或文件名，用斜杠分隔。</li><li><strong>查询参数（Query）</strong>：查询参数部分用于向服务器传递参数，通常以 <code>?</code> 开头，多个参数使用 <code>&amp;</code> 连接，例如 <code>?key1=value1&amp;key2=value2</code>。</li><li><strong>哈希值（Hash）</strong>：片段标识部分用于标识资源中的一个特定片段或锚点，通常以 <code>#</code> 开头。单页面应用的核心。</li></ul><h2 id="_4-解释一下什么是闭包" tabindex="-1">4. 解释一下什么是闭包 <a class="header-anchor" href="#_4-解释一下什么是闭包" aria-label="Permalink to &quot;4. 解释一下什么是闭包&quot;">​</a></h2><h3 id="闭包的概念" tabindex="-1">闭包的概念： <a class="header-anchor" href="#闭包的概念" aria-label="Permalink to &quot;闭包的概念：&quot;">​</a></h3><ul><li>闭包就是利用了这个函数执行空间不销毁的逻辑。</li><li>闭包就是能够读取其他函数内部变量的函数，或者把闭包理解成&quot;定义在一个函数内部的函数&quot;。</li></ul><h3 id="闭包的特点" tabindex="-1">闭包的特点： <a class="header-anchor" href="#闭包的特点" aria-label="Permalink to &quot;闭包的特点：&quot;">​</a></h3><ul><li><strong>作用域空间不销毁</strong>： <ul><li>优点：因为不销毁，变量也不会销毁，增加了变量的生命周期。</li><li>缺点：因为不销毁，会一直占用内存，多了以后就会导致内存溢出（手动销毁设为 <code>null</code>）。</li></ul></li><li><strong>可以利用闭包在一个函数外部访问函数内部的变量</strong>： <ul><li>优点：可以在函数外部访问内部数据。</li><li>缺点：必须要时刻保持引用，导致函数执行栈不被销毁。</li></ul></li><li><strong>保护私有变量</strong>： <ul><li>优点：可以把一些变量放在函数里面，不会污染全局。</li><li>缺点：要利用闭包函数才能访问，不是很方便。</li></ul></li></ul><h3 id="闭包的应用" tabindex="-1">闭包的应用： <a class="header-anchor" href="#闭包的应用" aria-label="Permalink to &quot;闭包的应用：&quot;">​</a></h3><ul><li>封装数据和行为：通过闭包，可以创建具有私有变量和方法的模块化代码，实现封装和隐藏细节。</li><li>函数防抖和节流以及柯里化：优化事件以及函数的参数。</li><li>异步编程：许多异步操作，如定时器和事件监听，涉及闭包，用于捕获外部的状态或上下文。</li><li>缓存和优化：闭包可用于缓存计算结果，以提高性能。</li></ul><p>需要注意的是，闭包可能会导致内存泄漏问题。如果闭包中引用的外部变量一直存在，那么这些变量也不会被垃圾回收，可能会造成内存资源的浪费。因此，在使用闭包时，要注意避免不必要的变量引用。</p><h2 id="_5-解释一下原型和原型链" tabindex="-1">5. 解释一下原型和原型链 <a class="header-anchor" href="#_5-解释一下原型和原型链" aria-label="Permalink to &quot;5. 解释一下原型和原型链&quot;">​</a></h2><h3 id="原型链的概念" tabindex="-1">原型链的概念： <a class="header-anchor" href="#原型链的概念" aria-label="Permalink to &quot;原型链的概念：&quot;">​</a></h3><p>实例对象与原型之间的连接叫做原型链，依靠 <code>__proto__</code> 实现的。</p><h3 id="原型链的访问原则" tabindex="-1">原型链的访问原则： <a class="header-anchor" href="#原型链的访问原则" aria-label="Permalink to &quot;原型链的访问原则：&quot;">​</a></h3><ul><li>访问一个对象的成员的时候，构造函数没有就会利用 <code>__proto__</code> 去构造函数的原型里面找。</li><li>如果构造函数原型里面没有就再去 <code>Object</code> 原型里面找。</li><li>如果 <code>Object.prototype</code> 里面都没有，那么就会返回 <code>undefined</code>。</li></ul><h2 id="_6-说一下-es6-中你熟悉的一些内容" tabindex="-1">6. 说一下 ES6 中你熟悉的一些内容 <a class="header-anchor" href="#_6-说一下-es6-中你熟悉的一些内容" aria-label="Permalink to &quot;6. 说一下 ES6 中你熟悉的一些内容&quot;">​</a></h2><h3 id="es6-ecmascript-2015-引入了一些重要的新特性和语法-包括但不限于" tabindex="-1">ES6（ECMAScript 2015）引入了一些重要的新特性和语法，包括但不限于： <a class="header-anchor" href="#es6-ecmascript-2015-引入了一些重要的新特性和语法-包括但不限于" aria-label="Permalink to &quot;ES6（ECMAScript 2015）引入了一些重要的新特性和语法，包括但不限于：&quot;">​</a></h3><ul><li><strong>let 和 const</strong>：用于声明变量和常量，具有块级作用域。</li><li><strong>箭头函数</strong>：简化函数表达式，并且不绑定自己的 <code>this</code>。</li><li><strong>模板字符串</strong>：使用反引号（<code>\`</code>）创建多行字符串和内嵌表达式。</li><li><strong>解构赋值</strong>：从数组和对象中提取值并赋值给变量。</li><li><strong>默认参数</strong>：为函数参数提供默认值。</li><li><strong>扩展运算符</strong>：用于展开数组或对象。</li><li><strong>类</strong>：引入了基于原型的面向对象编程的语法糖。</li><li><strong>模块</strong>：使用 <code>import</code> 和 <code>export</code> 语法进行模块化。</li><li><strong>Promise</strong>：用于处理异步操作。</li><li><strong>Symbol</strong>：创建独一无二的值。</li><li><strong>Map 和 Set</strong>：新的集合类型。</li><li><strong>增强的对象字面量</strong>：简化对象属性和方法的定义。</li></ul><h2 id="_7-什么是事件轮询-eventloop" tabindex="-1">7. 什么是事件轮询（EventLoop） <a class="header-anchor" href="#_7-什么是事件轮询-eventloop" aria-label="Permalink to &quot;7. 什么是事件轮询（EventLoop）&quot;">​</a></h2><p>JavaScript 是<strong>单线程</strong>的，只有<strong>一个主线程</strong>，一次只能执行一件事情。</p><h3 id="同步和异步" tabindex="-1">同步和异步： <a class="header-anchor" href="#同步和异步" aria-label="Permalink to &quot;同步和异步：&quot;">​</a></h3><ul><li><strong>同步</strong>：阻塞模式。</li><li><strong>异步</strong>：非阻塞模式。</li></ul><h3 id="异步代码进入任务队列" tabindex="-1">异步代码进入任务队列： <a class="header-anchor" href="#异步代码进入任务队列" aria-label="Permalink to &quot;异步代码进入任务队列：&quot;">​</a></h3><p>任务队列中的异步代码分为：宏任务和微任务。</p><ul><li><strong>宏任务</strong>：整个 <code>script</code> 代码，定时器，I/O（输入/输出）。</li><li><strong>微任务</strong>：<code>Promise.then</code>（<code>Promise</code> 里面的代码是同步的，<code>then</code> 里面的代码是异步的）。</li></ul><h3 id="事件轮询" tabindex="-1">事件轮询： <a class="header-anchor" href="#事件轮询" aria-label="Permalink to &quot;事件轮询：&quot;">​</a></h3><p>轮流询问宏任务队列和微任务队列，执行完一个宏任务，询问一次微任务队列，微任务队列有任务，就清空微任务队列，循环往复。因为整个 <code>script</code> 代码是宏任务，必须从宏任务开始，由此开始实现宏任务和微任务的划分。</p><h2 id="_8-promise-的使用场景" tabindex="-1">8. Promise 的使用场景 <a class="header-anchor" href="#_8-promise-的使用场景" aria-label="Permalink to &quot;8. Promise 的使用场景&quot;">​</a></h2><h3 id="使用场景" tabindex="-1">使用场景： <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景：&quot;">​</a></h3><ul><li><strong>异步操作</strong>：Promise 最常见的用途是处理异步操作，如网络请求、文件读写、定时器等。通过 Promise，可以更优雅地处理异步代码，避免嵌套的回调函数。</li><li><strong>链式调用</strong>：Promise 允许你将多个异步操作链接起来，形成一个链式调用的结构。这使得代码更具可读性，更容易理解和维护。</li><li><strong>并行操作</strong>：当有多个独立的异步操作需要同时进行时，可以使用 <code>Promise.all</code> 方法，等待所有异步操作都完成后执行下一步。</li><li><strong>条件执行</strong>：使用 Promise 可以根据某些条件来决定是否执行异步操作，例如，只有在某个条件满足时才发起网络请求。</li><li><strong>错误处理</strong>：Promise 提供了 <code>.catch</code> 方法，可以捕获异步操作中的错误，从而更好地进行错误处理和容错。</li><li><strong>资源加载</strong>：在前端开发中，可以使用 Promise 来加载图片、样式表等资源，以及等待页面的全部资源加载完成后再执行某些操作。</li><li><strong>定时任务</strong>：使用 Promise 可以更好地管理定时任务，例如，等待一段时间后执行某些操作。</li><li><strong>多次回调</strong>：在需要多次触发回调的场景下，可以使用 Promise 使代码更加结构化和易读。</li></ul><h2 id="_9-let-const-var-的区别" tabindex="-1">9. let, const, var 的区别 <a class="header-anchor" href="#_9-let-const-var-的区别" aria-label="Permalink to &quot;9. let, const, var 的区别&quot;">​</a></h2><h3 id="var" tabindex="-1"><code>var</code>： <a class="header-anchor" href="#var" aria-label="Permalink to &quot;\`var\`：&quot;">​</a></h3><ul><li><code>var</code> 是 ES5 中用于声明变量的关键字。</li><li>声明的变量存在变量提升，即在作用域内任何位置都可被访问，但值为 <code>undefined</code>。</li><li>在全局作用域下声明的变量会成为全局对象的属性。</li><li>可以重复声明相同名称的变量，不会抛出错误。</li><li>存在函数作用域，不会受块级作用域限制。</li></ul><h3 id="let" tabindex="-1"><code>let</code>： <a class="header-anchor" href="#let" aria-label="Permalink to &quot;\`let\`：&quot;">​</a></h3><ul><li><code>let</code> 是 ES6 中引入的块级作用域的变量声明关键字。</li><li>声明的变量不会变量提升，只有在声明语句后才能访问。</li><li>在同一作用域内，不允许重复声明同名变量。</li><li>不存在全局对象的属性。</li><li>变量的值可以被修改。</li></ul><h3 id="const" tabindex="-1"><code>const</code>： <a class="header-anchor" href="#const" aria-label="Permalink to &quot;\`const\`：&quot;">​</a></h3><ul><li><code>const</code> 也是 ES6 中引入的关键字，用于声明常量。</li><li>声明的常量具有块级作用域，且不会变量提升。</li><li>在同一作用域内，不允许重复声明同名变量或常量。</li><li>不存在全局对象的属性。</li><li>声明时必须初始化值，且之后不可再修改。</li></ul><p>总结来说，<code>let</code> 和 <code>const</code> 都是块级作用域的变量声明方式，而 <code>var</code> 是函数作用域的变量声明方式。在现代 JavaScript 中，推荐使用 <code>let</code> 和 <code>const</code> 来取代 <code>var</code>，以避免变量提升和其他潜在的问题。选择 <code>let</code> 还是 <code>const</code> 取决于是否需要变量值可修改。</p><h2 id="_10-对-this-的理解" tabindex="-1">10. 对 <code>this</code> 的理解 <a class="header-anchor" href="#_10-对-this-的理解" aria-label="Permalink to &quot;10. 对 \`this\` 的理解&quot;">​</a></h2><p>在 JavaScript 中，<code>this</code> 是一个特殊的关键字，它在不同的上下文中指向不同的对象。<code>this</code> 的值是动态确定的，取决于函数的调用方式和上下文。以下是一些常见情况下 <code>this</code> 的指向：</p><h3 id="全局上下文" tabindex="-1">全局上下文： <a class="header-anchor" href="#全局上下文" aria-label="Permalink to &quot;全局上下文：&quot;">​</a></h3><p>在全局作用域中，<code>this</code> 指向全局对象，通常是 <code>window</code> 对象（在浏览器环境中）或 <code>global</code> 对象（在 Node.js 环境中）。</p><h3 id="函数调用" tabindex="-1">函数调用： <a class="header-anchor" href="#函数调用" aria-label="Permalink to &quot;函数调用：&quot;">​</a></h3><ul><li>在普通函数调用中，<code>this</code> 指向调用该函数的对象。如果没有明确指定调用对象，则默认指向全局对象。</li><li>在严格模式下的函数内部，没有明确指定调用对象时，<code>this</code> 将是 <code>undefined</code>。</li><li>使用箭头函数时，<code>this</code> 的值由定义箭头函数的上下文决定，而不是调用方式。</li></ul><h3 id="方法调用" tabindex="-1">方法调用： <a class="header-anchor" href="#方法调用" aria-label="Permalink to &quot;方法调用：&quot;">​</a></h3><p>当函数作为对象的方法调用时，<code>this</code> 指向调用该方法的对象。</p><h3 id="构造函数" tabindex="-1">构造函数： <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数：&quot;">​</a></h3><p>当使用 <code>new</code> 关键字创建对象时，构造函数内部的 <code>this</code> 指向新创建的对象。</p><h3 id="dom-事件处理" tabindex="-1">DOM 事件处理： <a class="header-anchor" href="#dom-事件处理" aria-label="Permalink to &quot;DOM 事件处理：&quot;">​</a></h3><p>在事件处理函数中，<code>this</code> 通常指向触发事件的 DOM 元素。</p><h3 id="apply-和-call" tabindex="-1"><code>apply()</code> 和 <code>call()</code>： <a class="header-anchor" href="#apply-和-call" aria-label="Permalink to &quot;\`apply()\` 和 \`call()\`：&quot;">​</a></h3><p>通过 <code>apply()</code> 或 <code>call()</code> 方法可以显式地设置函数内部的 <code>this</code> 指向。</p><p>总之，<code>this</code> 的指向是相对灵活的，它的值在不同的情况下可能会有所不同。理解函数的调用方式以及上下文是确定 <code>this</code> 的关键因素。在 ES6 中，箭头函数可以在一定程度上避免 <code>this</code> 的混乱问题，因为箭头函数没有自己的 <code>this</code>，它会继承外部函数的 <code>this</code>。</p><h2 id="_11-call-apply-bind-的区别" tabindex="-1">11. <code>call</code>，<code>apply</code>，<code>bind</code> 的区别 <a class="header-anchor" href="#_11-call-apply-bind-的区别" aria-label="Permalink to &quot;11. \`call\`，\`apply\`，\`bind\` 的区别&quot;">​</a></h2><h3 id="call-方法" tabindex="-1"><code>call()</code> 方法： <a class="header-anchor" href="#call-方法" aria-label="Permalink to &quot;\`call()\` 方法：&quot;">​</a></h3><p><code>call</code> 方法允许你调用一个函数，并指定函数执行时的 <code>this</code> 值，以及将函数的参数按照参数列表传递。</p><h3 id="apply-方法" tabindex="-1"><code>apply()</code> 方法： <a class="header-anchor" href="#apply-方法" aria-label="Permalink to &quot;\`apply()\` 方法：&quot;">​</a></h3><p><code>apply</code> 方法与 <code>call</code> 类似，但它接受的参数是一个数组或类数组对象，将数组中的元素作为函数参数传递。</p><h3 id="bind-方法" tabindex="-1"><code>bind()</code> 方法： <a class="header-anchor" href="#bind-方法" aria-label="Permalink to &quot;\`bind()\` 方法：&quot;">​</a></h3><p><code>bind</code> 方法返回一个新的函数，该函数的 <code>this</code> 值被绑定到指定的对象。与 <code>call</code> 和 <code>apply</code> 不同，<code>bind</code> 并不会立即执行函数，而是返回一个新函数，你可以稍后调用这个新函数。</p><h3 id="总结区别" tabindex="-1">总结区别： <a class="header-anchor" href="#总结区别" aria-label="Permalink to &quot;总结区别：&quot;">​</a></h3><ol><li><strong>调用方式不同</strong>： <ul><li><code>call</code> 和 <code>apply</code> 是改变后就立即执行函数，<code>bind</code> 改变后不会立即执行，而是返回一个新的函数，需要再次调用。</li></ul></li><li><strong>参数不同</strong>： <ul><li><code>call</code> 第一个参数为 <code>this</code> 指向，从第二个参数开始是函数的参数。</li><li><code>bind</code> 第一个参数为 <code>this</code> 指向，从第二个参数开始是函数的参数，返回的是函数体，继续通过调用再次传入参数。</li><li><code>apply</code> 第一个参数为 <code>this</code> 指向，第二个参数是数组，函数自身的参数放到数组里面。</li></ul></li><li><strong>修改 <code>this</code> 的性质不同</strong>： <ul><li><code>call</code>、<code>apply</code> 只是临时的修改一次，修改就是 <code>call</code> 和 <code>apply</code> 方法使用的那一次；当再次调用原函数的时候，它的指向还是原来的指向。</li><li><code>bind</code> 是永久修改函数 <code>this</code> 指向，但是它修改的不是原来的函数，而是返回一个修改过后新的函数，此函数的 <code>this</code> 永远被改变了，绑定了就修改不了。</li></ul></li></ol><h2 id="_12-web-的存储方式有哪些" tabindex="-1">12. Web 的存储方式有哪些 <a class="header-anchor" href="#_12-web-的存储方式有哪些" aria-label="Permalink to &quot;12. Web 的存储方式有哪些&quot;">​</a></h2><h3 id="cookie、localstorage-和-sessionstorage-都是在浏览器中存储数据的方式-但它们在使用方式、生命周期和存储容量等方面有一些区别。" tabindex="-1">Cookie、localStorage 和 sessionStorage 都是在浏览器中存储数据的方式，但它们在使用方式、生命周期和存储容量等方面有一些区别。 <a class="header-anchor" href="#cookie、localstorage-和-sessionstorage-都是在浏览器中存储数据的方式-但它们在使用方式、生命周期和存储容量等方面有一些区别。" aria-label="Permalink to &quot;Cookie、localStorage 和 sessionStorage 都是在浏览器中存储数据的方式，但它们在使用方式、生命周期和存储容量等方面有一些区别。&quot;">​</a></h3><h3 id="_1-cookie" tabindex="-1">1. Cookie： <a class="header-anchor" href="#_1-cookie" aria-label="Permalink to &quot;1. Cookie：&quot;">​</a></h3><ul><li><code>cookie</code> 是一小段存储在用户本地计算机上的文本数据，由浏览器维护。</li><li>用于存储有限的数据，通常用于在客户端和服务器之间传递数据，例如用户会话信息、用户标识等。</li><li>可以设置过期时间，在过期之前一直存在于用户的计算机上。</li><li>在同一个域名下，所有页面共享同一组 <code>cookie</code>。</li><li>存储容量较小，通常为 4KB。</li></ul><h3 id="_2-localstorage" tabindex="-1">2. localStorage： <a class="header-anchor" href="#_2-localstorage" aria-label="Permalink to &quot;2. localStorage：&quot;">​</a></h3><ul><li><code>localStorage</code> 是 HTML5 引入的一种本地存储方式，存储在用户本地计算机上。</li><li>用于长期存储数据，即使用户关闭浏览器或重新打开页面，数据仍然保留。</li><li>存储容量较大，通常为 5MB 或更多，但不同浏览器可能略有差异。</li><li>在同一个域名下，所有页面共享同一片 <code>localStorage</code> 区域。</li></ul><h3 id="_3-sessionstorage" tabindex="-1">3. sessionStorage： <a class="header-anchor" href="#_3-sessionstorage" aria-label="Permalink to &quot;3. sessionStorage：&quot;">​</a></h3><ul><li><code>sessionStorage</code> 与 <code>localStorage</code> 类似，也是存储在用户本地计算机上的本地存储方式。</li><li>用于临时存储会话数据，只在<strong>当前会话窗口有效，关闭窗口后数据会被清除</strong>。</li><li>存储容量较大，通常与 <code>localStorage</code> 一样为 5MB 或更多。</li><li>在同一个域名下，不同的会话窗口（标签页）有各自独立的 <code>sessionStorage</code> 区域。</li></ul><h3 id="总结-1" tabindex="-1">总结： <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结：&quot;">​</a></h3><ul><li><code>cookie</code> 主要用于传递数据和保持会话状态，适用于小量数据。</li><li><code>localStorage</code> 用于长期存储数据，适用于大量数据需要长时间保存的情况。</li><li><code>sessionStorage</code> 用于临时会话数据存储，适用于当前会话期间的数据共享。</li></ul><p>在选择存储方式时，需要根据需求来确定使用哪种方式，以便在不同的场景中实现最佳的数据存储和交互效果。</p><h2 id="_13-输入-url-到打开页面都做了什么事情-计网" tabindex="-1">13. 输入 URL 到打开页面都做了什么事情？（计网） <a class="header-anchor" href="#_13-输入-url-到打开页面都做了什么事情-计网" aria-label="Permalink to &quot;13. 输入 URL 到打开页面都做了什么事情？（计网）&quot;">​</a></h2><p>从输入 URL 到打开页面的过程可以分为以下几个主要步骤：</p><ol><li><strong>URL 解析</strong>：浏览器首先对输入的 URL 进行解析，分析出协议、域名、端口号、路径、查询参数等信息。</li><li><strong>DNS 查询</strong>：如果域名不是 IP 地址，浏览器会向服务器发送请求，将域名解析为 IP 地址。DNS 解析结果通常会被缓存，以提高后续访问的速度。</li><li><strong>建立 TCP 连接</strong>：浏览器使用解析得到的 IP 地址和目标端口号，通过 TCP/IP 协议建立与服务器的网络连接。</li><li><strong>发起 HTTP 请求</strong>：浏览器向服务器发送 HTTP 请求，请求包括请求方法、请求头、请求体等信息。</li><li><strong>服务器处理请求</strong>：服务器接收并处理浏览器发送的请求，根据请求的路径和参数等，返回对应的响应内容。</li><li><strong>接收响应</strong>：浏览器接收来自服务器的响应，响应包括状态码、响应头和响应体等信息。</li><li><strong>渲染页面</strong>：浏览器根据响应内容中的 HTML、CSS、JavaScript 等资源开始渲染页面，构建 DOM 树和渲染树，展示页面内容。</li><li><strong>下载资源</strong>：浏览器解析 HTML 中的链接和资源标签（<code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>等），发起对这些资源的请求，并下载对应的资源文件。</li><li><strong>解析和执行 JavaScript</strong>：浏览器下载并解析页面中的 JavaScript 文件，执行其中的脚本代码，可能会对页面进行修改或添加交互功能。</li><li><strong>页面加载完成</strong>：当所有资源下载完成，页面渲染完成，JavaScript 代码执行完毕后，页面加载完成。</li></ol><h2 id="_14-null-和-undefined-的区别" tabindex="-1">14. null 和 undefined 的区别？ <a class="header-anchor" href="#_14-null-和-undefined-的区别" aria-label="Permalink to &quot;14. null 和 undefined 的区别？&quot;">​</a></h2><ul><li><p><code>null</code> 是一个表示&quot;无&quot;的对象（空对象指针），转为数值时为 0；</p><ul><li><code>null</code> 表示&quot;没有对象&quot;，即该处不应该有值。</li><li>典型用法是： <ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ul></li></ul></li><li><p><code>undefined</code> 是一个表示&quot;无&quot;的原始值，转为数值时为 NaN。</p><ul><li><code>undefined</code> 表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。</li><li>典型用法是： <ul><li>变量被声明了，但没有赋值时，就等于<code>undefined</code>。</li><li>调用函数时，应该提供的参数没有提供，该参数等于<code>undefined</code>。</li><li>对象没有赋值的属性，该属性的值为<code>undefined</code>。</li><li>函数没有返回值时，默认返回<code>undefined</code>。</li></ul></li></ul></li></ul><h2 id="_15-什么是-promise" tabindex="-1">15. 什么是 Promise？ <a class="header-anchor" href="#_15-什么是-promise" aria-label="Permalink to &quot;15. 什么是 Promise？&quot;">​</a></h2><p>Promise 是 JavaScript 中用于处理异步操作的一种机制，它是一种表示未来可能会完成或失败的操作的对象。Promise 可以将异步操作封装成一个对象，从而更好地管理异步代码的流程，避免了回调地狱的问题。</p><p>Promise 有三种状态：</p><ul><li><strong>Pending（进行中）</strong>： 初始状态，表示异步操作正在进行中，尚未完成也未失败。</li><li><strong>Fulfilled（已成功）</strong>： 表示异步操作已成功完成，可以获取到操作的结果。</li><li><strong>Rejected（已失败）</strong>： 表示异步操作失败，可以获取到失败的原因。</li></ul><p>一个 Promise 对象可以被链式调用，通过 <code>.then()</code> 方法来注册回调函数，分别处理成功和失败的情况。此外，Promise 还提供了 <code>.catch()</code> 方法来捕获错误，以及 <code>.finally()</code> 方法来添加在无论成功或失败都会执行的逻辑。</p><p>Promise 的出现使得异步操作的处理更加规范、可读、可维护，同时也提供了更好的错误处理机制。不过，随着 ES6 及之后的规范的发展，<code>async/await</code> 成为了一种更直观、简洁的处理异步操作的方式，你可以根据项目需求选择适合的异步处理方式。</p><h2 id="_16-普通函数与箭头函数的区别" tabindex="-1">16. 普通函数与箭头函数的区别？ <a class="header-anchor" href="#_16-普通函数与箭头函数的区别" aria-label="Permalink to &quot;16. 普通函数与箭头函数的区别？&quot;">​</a></h2><ol><li><strong>语法</strong>：箭头函数的语法更为简洁，通常可以在一行中完成函数的定义，而普通函数需要使用 <code>function</code> 关键字。</li><li><strong>this 的绑定</strong>：箭头函数的 <code>this</code> 始终指向定义时的上下文，而普通函数的 <code>this</code> 则在运行时根据函数的调用方式动态绑定。</li><li><strong>构造函数</strong>：箭头函数不能用作构造函数，不能使用 <code>new</code> 关键字调用，也没有自己的 <code>prototype</code>。</li><li><strong>返回值</strong>：箭头函数如果只有一条表达式，可以省略花括号并且自动返回该表达式的值。但如果需要多条语句或复杂逻辑，仍然需要使用花括号并显式返回值。</li></ol><p>总的来说，普通函数和箭头函数在不同的场景中有不同的用途，根据需要选择合适的函数类型。普通函数适用于需要动态绑定 <code>this</code>、需要使用 <code>arguments</code> 对象、或需要用作构造函数的情况，而箭头函数适用于简单的函数表达式、避免 <code>this</code> 问题以及需要简洁的代码块的情况。</p><h2 id="_17-设计模式有哪些-分别说一说-详见面试官系列-设计模式" tabindex="-1">17. 设计模式有哪些, 分别说一说？（详见面试官系列-设计模式） <a class="header-anchor" href="#_17-设计模式有哪些-分别说一说-详见面试官系列-设计模式" aria-label="Permalink to &quot;17. 设计模式有哪些, 分别说一说？（详见面试官系列-设计模式）&quot;">​</a></h2><h3 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h3><p>单例模式是一种创建型设计模式，确保一个类只有一个实例，并提供一个全局访问点。</p><h3 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to &quot;策略模式&quot;">​</a></h3><p>策略模式是一种行为型设计模式，定义了一系列算法，并将每个算法封装起来，使它们可以相互替换。策略模式使得算法可以在不影响客户端的情况下发生变化。</p><h3 id="发布订阅模式" tabindex="-1">发布订阅模式 <a class="header-anchor" href="#发布订阅模式" aria-label="Permalink to &quot;发布订阅模式&quot;">​</a></h3><p>发布订阅模式是一种行为型设计模式，定义了对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。</p><h2 id="_18-promise-和-async-await-的区别和使用" tabindex="-1">18. Promise 和 async/await 的区别和使用？ <a class="header-anchor" href="#_18-promise-和-async-await-的区别和使用" aria-label="Permalink to &quot;18. Promise 和 async/await 的区别和使用？&quot;">​</a></h2><ol><li><strong>都是处理异步请求的方式</strong>。</li><li><strong>Promise 是 ES6</strong>，<code>async/await</code>是 ES7 的语法。</li><li><code>async/await</code>是基于 Promise 实现的，它们都是异步的。</li><li><strong>Promise</strong>是返回对象，要使用<code>then</code>和<code>catch</code>方法去处理和捕获异常，并且书写方式是链式的，容易造成代码重叠，维护不好。<code>async/await</code>是通过<code>try/catch</code>进行异常处理。</li><li><code>async/await</code>最大的优点是代码看起来像同步一样，只要遇到<code>await</code>就会立刻返回结果，然后再执行后面的操作，而 Promise 是通过<code>then</code>的方式返回，会出现请求还没有返回，就执行了后面的同步操作。</li></ol><h2 id="_19-new-一个对象的过程" tabindex="-1">19. new 一个对象的过程？ <a class="header-anchor" href="#_19-new-一个对象的过程" aria-label="Permalink to &quot;19. new 一个对象的过程？&quot;">​</a></h2><ol><li><strong>开辟一个堆内存</strong>，将名称放到栈内存中，创建一个空对象。</li><li><strong>执行构造函数</strong>，对这个空对象进行构造，绑定成员。</li><li><strong>给这个空对象添加<code>__proto__</code>属性</strong>，访问原型链上面的成员。</li><li><strong>隐式返回<code>this</code></strong>。</li></ol><h2 id="_20-http-的理解-计网" tabindex="-1">20. HTTP 的理解？（计网） <a class="header-anchor" href="#_20-http-的理解-计网" aria-label="Permalink to &quot;20. HTTP 的理解？（计网）&quot;">​</a></h2><p>HTTP 是一种用于在网络上进行数据通信的协议，它是客户端（通常是浏览器）和服务器之间进行通信的基础。</p><h3 id="http-的特点" tabindex="-1">HTTP 的特点 <a class="header-anchor" href="#http-的特点" aria-label="Permalink to &quot;HTTP 的特点&quot;">​</a></h3><ol><li><strong>无状态协议</strong>： HTTP 是无状态协议，这意味着每个请求和响应都是独立的。</li><li><strong>请求方法</strong>： HTTP 定义了多种请求方法，最常见的是 GET、POST、PUT 和 DELETE。</li><li><strong>HTTP 状态码</strong>： 服务器在响应中使用状态码来表示请求的处理结果。</li><li><strong>持久连接</strong>： 为减少每次请求都要重新建立连接的开销，HTTP 支持持久连接，允许多个请求在同一个连接上进行。</li><li><strong>安全性</strong>： HTTP 是明文协议，数据在传输过程中可能会被窃听或篡改。为了增加安全性，可以使用 HTTPS。</li><li><strong>缓存</strong>： HTTP 支持客户端和服务器之间的缓存机制，可以减少重复请求相同资源的网络传输。</li></ol><p>HTTP 是 Web 开发中的重要基础，通过 HTTP 客户端和服务器可以进行数据交换和通信，实现了万维网的基本功能。</p><h2 id="_21-http-和-https-的区别-计网" tabindex="-1">21. HTTP 和 HTTPS 的区别（计网） <a class="header-anchor" href="#_21-http-和-https-的区别-计网" aria-label="Permalink to &quot;21. HTTP 和 HTTPS 的区别（计网）&quot;">​</a></h2><p>HTTP 和 HTTPS 是两种在网络上进行数据通信的协议，它们之间存在一些重要的区别：</p><ol><li><p><strong>安全性</strong>：</p><ul><li>HTTP 是明文协议，数据在传输过程中不加密，容易被窃听和篡改。</li><li>HTTPS 使用 SSL/TLS 协议对数据进行加密和认证，保障了数据的机密性和完整性，防止数据被恶意拦截或篡改。</li></ul></li><li><p><strong>端口</strong>：</p><ul><li>HTTP 默认使用端口 80。</li><li>HTTPS 默认使用端口 443。这两种协议使用不同的端口，方便服务器识别并处理不同的协议请求。</li></ul></li><li><p><strong>证书</strong>：</p><ul><li>HTTPS 需要使用 SSL/TLS 数字证书来验证服务器的身份。这些证书由受信任的证书颁发机构（CA）签发，用于证明服务器是合法的，可以建立安全连接。</li><li>HTTP 不需要证书验证。</li></ul></li><li><p><strong>搜索引擎排名</strong>：</p><ul><li>搜索引擎通常会偏向显示使用 HTTPS 的网站，因为 HTTPS 提供了更高的安全性。这可能会影响网站的搜索引擎排名。</li></ul></li><li><p><strong>性能</strong>：</p><ul><li>由于 HTTPS 需要进行加密和解密操作，相对于 HTTP 会稍微增加一些网络传输的开销，可能会稍微降低性能。但是，现代的加密算法和硬件性能使得这种差距已经减小。</li></ul></li></ol><h2 id="_22-三次握手和四次挥手-计网" tabindex="-1">22. 三次握手和四次挥手（计网） <a class="header-anchor" href="#_22-三次握手和四次挥手-计网" aria-label="Permalink to &quot;22. 三次握手和四次挥手（计网）&quot;">​</a></h2><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>三次握手是网络客户端和服务器之间建立连接并进行通信的过程，分为三个步骤：</p><ol><li><strong>第一次握手</strong>：客户端发送连接请求报文，并传送规定的数据包。</li><li><strong>第二次握手</strong>：服务器端表示接收到连接请求报文，并回传规定的数据包。</li><li><strong>第三次握手</strong>：客户端接收到服务器回传的数据包后，给服务器端再次发送数据包。这样就完成了客户端和服务器的连接和数据传送。</li></ol><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p>四次挥手表示当前连接请求已经结束，要断开这次连接，分为四个步骤：</p><ol><li><strong>第一次挥手</strong>：客户端对服务器发起断开请求。</li><li><strong>第二次挥手</strong>：服务器表示收到这次断开请求。</li><li><strong>第三次挥手</strong>：服务器表示已经断开连接。</li><li><strong>第四次挥手</strong>：客户端断开连接。</li></ol><h2 id="_23-promise-all-的使用" tabindex="-1">23. Promise.all() 的使用 <a class="header-anchor" href="#_23-promise-all-的使用" aria-label="Permalink to &quot;23. Promise.all() 的使用&quot;">​</a></h2><p><code>Promise.all()</code> 是一个常用的 Promise 方法，用于将多个 Promise 对象包装成一个新的 Promise，等待所有的 Promise 对象都成功完成或有一个失败时返回一个拒绝状态。</p><h3 id="使用方法" tabindex="-1">使用方法 <a class="header-anchor" href="#使用方法" aria-label="Permalink to &quot;使用方法&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> promise1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> promise2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> promise3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolve, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([promise1, promise2, promise3])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(values); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [3, 42, &quot;foo&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;One of the promises failed:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span></code></pre></div><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><ul><li>如果传入的数组中有任何一个不是 Promise 对象，<code>Promise.all()</code> 会自动将其转换为一个已解决的 Promise 对象。</li><li>如果其中一个 Promise 失败了，整个 <code>Promise.all()</code> 就会立即失败，并且不会等待其他的 Promise 完成。</li><li>如果希望即使有些 Promise 失败，仍然继续处理其他成功的结果，可以考虑使用 <code>Promise.allSettled()</code> 方法。</li></ul><h2 id="_24-async-await-的错误处理" tabindex="-1">24. async/await 的错误处理 <a class="header-anchor" href="#_24-async-await-的错误处理" aria-label="Permalink to &quot;24. async/await 的错误处理&quot;">​</a></h2><p>在使用 async/await 时，可以使用 try 和 catch 来捕获和处理异步操作中的错误异常。async/await 使得在异步代码中捕获错误异常变得更加直观和类似于同步代码的方式。</p><h3 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://api.example.com/data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">response.ok) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Request failed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;An error occurred:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error.message);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    throw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> error; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 抛出错误，可以继续在上层捕获</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Data:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, result);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Error in main:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error.message);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h3 id="说明" tabindex="-1">说明 <a class="header-anchor" href="#说明" aria-label="Permalink to &quot;说明&quot;">​</a></h3><ul><li><code>fetchData()</code> 函数使用 try 块包裹可能会抛出错误的代码块，然后使用 throw 关键字抛出错误。在 catch 块中，可以捕获错误并进行适当的处理，比如打印错误信息。</li><li><code>main()</code> 函数中，同样使用 try 块来调用 <code>fetchData()</code>，并在 catch 块中捕获 <code>fetchData()</code> 中可能抛出的错误。这样，可以在异步代码中优雅地处理错误异常。</li></ul><h2 id="_25-http-常见的响应状态码-计网" tabindex="-1">25. HTTP 常见的响应状态码（计网） <a class="header-anchor" href="#_25-http-常见的响应状态码-计网" aria-label="Permalink to &quot;25. HTTP 常见的响应状态码（计网）&quot;">​</a></h2><p>HTTP 响应状态码是用以表示网页服务器 HTTP（超文本传输协议）响应状态的三位数字代码，分为以下几类：</p><h3 id="状态码类别" tabindex="-1">状态码类别 <a class="header-anchor" href="#状态码类别" aria-label="Permalink to &quot;状态码类别&quot;">​</a></h3><ul><li><strong>1xx 消息类</strong>：代表请求已被接受，需要继续处理</li><li><strong>2xx 成功类</strong>：代表请求已成功被服务器接收、理解、并接受</li><li><strong>3xx 重定向</strong>：代表需要客户端采取进一步的操作才能完成请求</li><li><strong>4xx 客户端错误</strong>：代表客户端看起来可能发生了错误，妨碍了服务器的处理</li><li><strong>5xx 服务器错误</strong>：代表服务器在处理请求的过程中有错误或者异常状态发生</li></ul><h3 id="常见状态码" tabindex="-1">常见状态码 <a class="header-anchor" href="#常见状态码" aria-label="Permalink to &quot;常见状态码&quot;">​</a></h3><ul><li><strong>101</strong>：服务器已经理解了客户端的请求，并将通过消息头通知客户端采用不同的协议来完成这个请求。</li><li><strong>200</strong>：请求成功。</li><li><strong>304</strong>：客户端发送了一个带条件的 GET 请求且该请求已被允许，而 HTML 文档的内容并没有改变，则服务器应当返回这个状态码。</li><li><strong>403</strong>：服务器已经理解请求，但是拒绝执行它。</li><li><strong>404</strong>：请求失败，请求所希望得到的资源未被在服务器上发现。</li><li><strong>501</strong>：服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</li><li><strong>503</strong>：由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。</li></ul><h2 id="_26-事件流及其传播机制" tabindex="-1">26. 事件流及其传播机制 <a class="header-anchor" href="#_26-事件流及其传播机制" aria-label="Permalink to &quot;26. 事件流及其传播机制&quot;">​</a></h2><p>事件流是指在 Web 页面中，事件（比如点击、鼠标移动、键盘输入等）在不同元素之间传播的过程。事件流描述了从事件触发开始，如何在 DOM 树中传播，直到达到最终目标元素，然后再从目标元素开始向上冒泡回到根元素。</p><h3 id="事件流的传播机制" tabindex="-1">事件流的传播机制 <a class="header-anchor" href="#事件流的传播机制" aria-label="Permalink to &quot;事件流的传播机制&quot;">​</a></h3><ol><li><strong>捕获阶段</strong>：事件从根元素开始逐级向下传播，一直到目标元素。这个阶段主要用于在事件到达目标元素之前，可以在父级元素上进行一些处理。</li><li><strong>目标阶段</strong>：事件达到目标元素，触发目标元素上的事件处理函数。这是事件的实际触发阶段。</li><li><strong>冒泡阶段</strong>：事件从目标元素开始向上冒泡，逐级回到根元素。在冒泡阶段，可以在父级元素上捕获到事件并进行处理。</li></ol><h3 id="事件传播的顺序" tabindex="-1">事件传播的顺序 <a class="header-anchor" href="#事件传播的顺序" aria-label="Permalink to &quot;事件传播的顺序&quot;">​</a></h3><p>事件传播的顺序是从根元素到目标元素的捕获阶段，然后从目标元素到根元素的冒泡阶段。在每个阶段，可以通过添加事件监听器来捕获或处理事件。</p><h2 id="_27-模块化语法" tabindex="-1">27. 模块化语法 <a class="header-anchor" href="#_27-模块化语法" aria-label="Permalink to &quot;27. 模块化语法&quot;">​</a></h2><p>模块化语法用于解决代码冲突和依赖问题。常见的模块化规范包括：</p><ol><li><strong>CommonJS</strong>：2009 年诞生的最早的模块规范，基于服务器端规范，Node.js 实现了这一规范。 <ul><li>规则：一个 JS 文件就是一个模块。定义模块、调用模块、配置模块。</li></ul></li><li><strong>AMD</strong>：异步的模块定义，基于 CommonJS 的讨论诞生，浏览器端的异步规范，Require.js 实现了这个规范。</li><li><strong>CMD</strong>：通用的模块定义，国内的规范，Sea.js 实现了这个规范。</li><li><strong>ES6 模块化</strong>：ES6 在语言标准层面上实现了模块功能，简单且可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li></ol><h2 id="_28-懒加载和预加载" tabindex="-1">28. 懒加载和预加载 <a class="header-anchor" href="#_28-懒加载和预加载" aria-label="Permalink to &quot;28. 懒加载和预加载&quot;">​</a></h2><h3 id="懒加载" tabindex="-1">懒加载 <a class="header-anchor" href="#懒加载" aria-label="Permalink to &quot;懒加载&quot;">​</a></h3><p>懒加载是在页面初始加载时只加载首屏可见区域的内容，延迟加载其他非首屏内容，只有当用户滚动页面到需要加载的内容时才进行加载。</p><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ul><li>减少初始加载时间，提高首屏渲染速度。</li><li>节省带宽，不会一次性加载所有资源。</li><li>适用于长页面，用户只加载感兴趣的部分。</li></ul><h3 id="预加载" tabindex="-1">预加载 <a class="header-anchor" href="#预加载" aria-label="Permalink to &quot;预加载&quot;">​</a></h3><p>预加载是在页面加载时提前加载将来可能会用到的资源，而不是等到用户需要时再加载。这可以通过在页面上添加 <code>&lt;link&gt;</code> 或 <code>&lt;script&gt;</code> 标签来实现。</p><h4 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h4><ul><li>提前加载资源，减少后续页面切换的延迟。</li><li>改善用户体验，用户不会感到等待。</li><li>适用于单页面应用等需要快速响应用户交互的场景。</li></ul><h3 id="注意事项-1" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项-1" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><p>懒加载和预加载都需要谨慎使用，过度使用可能会影响用户体验。例如，滥用懒加载可能导致用户滚动时出现内容闪烁或延迟加载过多的资源导致页面反应不及时。而预加载可能会在某些情况下浪费带宽，因为不是所有预加载的资源都会被用户访问到。</p><h2 id="_29-javascript-中的浮点数精度问题-计组" tabindex="-1">29. JavaScript 中的浮点数精度问题（计组） <a class="header-anchor" href="#_29-javascript-中的浮点数精度问题-计组" aria-label="Permalink to &quot;29. JavaScript 中的浮点数精度问题（计组）&quot;">​</a></h2><p>JavaScript 中的浮点数精度问题是由于使用 IEEE 754 标准来表示浮点数（包括小数）导致的。IEEE 754 标准使用二进制来表示浮点数，但有些小数（例如 0.1 和 0.2）在二进制中无法精确表示，就像十进制中无法精确表示 1/3 一样。这导致了在计算机内部进行浮点数运算时可能会出现舍入误差，进而导致看似相等的数值在比较时不相等。</p><h3 id="示例-1" tabindex="-1">示例 <a class="header-anchor" href="#示例-1" aria-label="Permalink to &quot;示例&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 0.30000000000000004</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 false</span></span></code></pre></div><h3 id="解决方法" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法" aria-label="Permalink to &quot;解决方法&quot;">​</a></h3><ol><li><strong>使用整数运算</strong>：将浮点数转换为整数进行计算，最后再转换回浮点数。例如，将小数乘以 10 或 100，进行整数运算，然后再除以相应的倍数。</li><li><strong>使用 <code>toFixed()</code> 方法</strong>：使用 <code>.toFixed()</code> 方法来控制小数的精度，但请注意它返回的是字符串而非数值。</li><li><strong>使用第三方库</strong>：一些第三方库，如 <code>decimal.js</code>、<code>big.js</code> 等，提供了更精确的浮点数计算。</li></ol><h2 id="_30-token-一般存放在哪里-为什么不存放在-cookie-内" tabindex="-1">30. token 一般存放在哪里 ? 为什么不存放在 cookie 内 ? <a class="header-anchor" href="#_30-token-一般存放在哪里-为什么不存放在-cookie-内" aria-label="Permalink to &quot;30. token 一般存放在哪里 ? 为什么不存放在 cookie 内 ?&quot;">​</a></h2><p>Token 通常用于在客户端和服务器之间进行身份验证和授权。它是一种轻量级的身份验证方式，可以避免在每个请求中都需要携带用户的敏感信息，提供了更好的安全性和性能。</p><h3 id="存放位置" tabindex="-1">存放位置 <a class="header-anchor" href="#存放位置" aria-label="Permalink to &quot;存放位置&quot;">​</a></h3><ol><li><p><strong>HTTP 标头</strong>：</p><ul><li>Token 可以放置在请求的 HTTP 标头中，通常使用 &quot;Authorization&quot; 标头。例如，Bearer Token 可以这样存放：</li></ul><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /api/data</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Authorization</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Bearer your_access_token_here</span></span></code></pre></div><ul><li>优势：Token 不会被浏览器自动包含在每个请求中，需要手动添加，降低了跨站脚本攻击（XSS）的风险。同时，也能避免跨站请求伪造（CSRF）攻击。</li></ul></li><li><p><strong>浏览器的本地存储</strong>：</p><ul><li>Token 也可以存放在浏览器的本地存储中，如 Cookie、本地存储（LocalStorage）、会话存储（SessionStorage）等。</li><li>注意：存放在 Cookie 中可能存在一些安全风险，因为 Cookie 会在每个请求中自动发送，存在被劫持的风险。此外，Cookie 有一些限制，例如大小限制和跨域限制。</li></ul></li></ol><h3 id="建议" tabindex="-1">建议 <a class="header-anchor" href="#建议" aria-label="Permalink to &quot;建议&quot;">​</a></h3><p>为了避免存放在 Cookie 中的安全问题，一般建议将 Token 存放在 HTTP 标头中，使用 &quot;Authorization&quot; 标头进行传递。这样可以更好地控制 Token 的使用和保护，提高应用的安全性。同时，也可以考虑使用 HttpOnly 和 Secure 标志来加强 Cookie 的安全性。</p><h2 id="_31-浏览器的同源策略机制" tabindex="-1">31. 浏览器的同源策略机制 <a class="header-anchor" href="#_31-浏览器的同源策略机制" aria-label="Permalink to &quot;31. 浏览器的同源策略机制&quot;">​</a></h2><p>同源策略是一种重要的安全机制，用于防止不同来源的文档或脚本相互访问数据。它限制了一个源（域名、协议和端口）上的网页如何与另一个源上的资源进行交互。</p><h3 id="同源策略的规则" tabindex="-1">同源策略的规则 <a class="header-anchor" href="#同源策略的规则" aria-label="Permalink to &quot;同源策略的规则&quot;">​</a></h3><ol><li><strong>域名不同</strong>：<code>http://example.com</code> 和 <code>http://example.org</code> 属于不同的源。</li><li><strong>协议不同</strong>：<code>http://example.com</code> 和 <code>https://example.com</code> 属于不同的源。</li><li><strong>端口不同</strong>：<code>http://example.com:80</code> 和 <code>http://example.com:8080</code> 属于不同的源。</li><li><strong>一级域名和二级域名</strong>：<code>https://www.baidu.com</code> 和 <code>https://news.baidu.com</code> 属于不同的源。</li><li><strong>域名与对应的 IP 地址</strong>：<code>http://localhost</code> 和 <code>http://127.0.0.1</code> 属于不同的源。</li></ol><h2 id="_32-浏览器的缓存有哪些-什么时候使用强制缓存-什么时候使用协商缓存" tabindex="-1">32. 浏览器的缓存有哪些 ? 什么时候使用强制缓存 ? 什么时候使用协商缓存 ? <a class="header-anchor" href="#_32-浏览器的缓存有哪些-什么时候使用强制缓存-什么时候使用协商缓存" aria-label="Permalink to &quot;32. 浏览器的缓存有哪些 ? 什么时候使用强制缓存 ? 什么时候使用协商缓存 ?&quot;">​</a></h2><p>浏览器的缓存机制有两种主要类型：强制缓存和协商缓存。它们都用于减少网络请求，提高页面加载速度，但在不同的情况下使用。</p><h3 id="_1-强制缓存" tabindex="-1">1. 强制缓存： <a class="header-anchor" href="#_1-强制缓存" aria-label="Permalink to &quot;1. 强制缓存：&quot;">​</a></h3><p>强制缓存是浏览器直接使用缓存副本，而不需要与服务器进行通信的方式。在强制缓存有效期内，浏览器会直接从缓存中加载资源，不会发出请求。强制缓存可以通过设置响应头来控制，常见的响应头有 Cache-Control 和 Expires。</p><p>强制缓存适用于那些不经常变化的资源，如静态资源（如样式表、图片、脚本等）。在用户首次访问页面时，服务器返回资源，并在响应头中设置强制缓存规则。之后，用户再次访问相同页面时，浏览器会从缓存中加载资源，减少了不必要的网络请求。</p><p>浏览器在强制缓存有效期内直接使用缓存副本，不与服务器通信。常见的响应头有 <code>Cache-Control</code> 和 <code>Expires</code>。</p><ul><li><strong>适用场景</strong>：不经常变化的资源，如静态资源（样式表、图片、脚本等）。</li><li><strong>设置示例</strong>：<div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Cache-Control</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> max-age=3600</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Expires</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Wed, 21 Oct 2021 07:28:00 GMT</span></span></code></pre></div></li></ul><h3 id="_2-协商缓存" tabindex="-1">2. 协商缓存： <a class="header-anchor" href="#_2-协商缓存" aria-label="Permalink to &quot;2. 协商缓存：&quot;">​</a></h3><p>协商缓存是在强制缓存过期后，浏览器会向服务器发出请求，询问服务器资源是否有更新。服务器通过响应头中的 ETag（实体标签）或 Last-Modified（最后修改时间）来告知浏览器资源是否已经改变。如果资源没有改变，服务器会返回 304 Not Modified，浏览器会直接从缓存中加载资源。如果资源已经改变，服务器会返回新的资源内容。</p><p>强制缓存失效后，浏览器会向服务器发请求，询问资源是否有更新。服务器通过 <code>ETag</code> 或 <code>Last-Modified</code> 响应头告知浏览器资源是否改变。</p><ul><li><strong>适用场景</strong>：经常变化的资源。</li><li><strong>设置示例</strong>：<div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ETag</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;5d8c72a5edda3c6a&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Last-Modified</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Wed, 21 Oct 2021 07:28:00 GMT</span></span></code></pre></div></li></ul><p>综合来看，强制缓存适用于稳定不变的资源，协商缓存适用于经常变化的资源。根据资源的特性和需求，可以选择合适的缓存策略来优化页面加载性能。</p><h2 id="_33-函数作用域和作用域链" tabindex="-1">33. 函数作用域和作用域链 <a class="header-anchor" href="#_33-函数作用域和作用域链" aria-label="Permalink to &quot;33. 函数作用域和作用域链&quot;">​</a></h2><h3 id="函数作用域" tabindex="-1">函数作用域 <a class="header-anchor" href="#函数作用域" aria-label="Permalink to &quot;函数作用域&quot;">​</a></h3><p>函数作用域是指在 JavaScript 中，每个函数都创建了一个自己的作用域（作用范围）。这意味着函数内部定义的变量和函数，在函数外部是不可访问的，它们只在函数内部有效。函数作用域是一种限制变量和函数可见性和访问性的机制，有助于避免命名冲突和变量污染。</p><p>在函数作用域中，变量的生命周期从变量被声明开始，一直到函数执行结束或变量被销毁。这样的机制使得每个函数都可以维护自己的状态，不会与其他函数发生冲突。</p><p>在 JavaScript 中，每个函数都有自己的作用域。函数内部定义的变量和函数在函数外部不可访问。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// x 在函数作用域中有效</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 会报错，x 在外部不可访问</span></span></code></pre></div><h3 id="作用域链" tabindex="-1">作用域链 <a class="header-anchor" href="#作用域链" aria-label="Permalink to &quot;作用域链&quot;">​</a></h3><p>作用域链是指每个作用域都有一个连接到上一级作用域的链，形成一个层次结构。变量查找时会沿着作用域链向上逐级查找，直到找到匹配的标识符或到达全局作用域。</p><p>作用域链是指在 JavaScript 中，每个作用域都有一个连接到上一级作用域的链，形成一个作用域的层次结构。当查找变量或函数时，JavaScript 引擎会沿着作用域链向上逐级查找，直到找到匹配的标识符或到达全局作用域为止。这种机制使得内部作用域可以访问外部作用域的变量和函数，但外部作用域不能访问内部作用域的变量。</p><p>作用域链的构建是在函数定义的时候确定的，而不是在函数执行的时候。每当函数被创建时，它会记住自己被定义时的作用域链，这样在函数执行时就可以正确地访问外部作用域的变量。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> globalVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;I am global&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> outerVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;I am outer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;I am inner&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(globalVar); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以访问全局作用域中的变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(outerVar); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以访问外部作用域中的变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(innerVar); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 无法访问内部作用域中的变量</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>作用域链的概念是理解 JavaScript 变量作用域和可访问性的关键，它使得嵌套函数可以正确地访问外部作用域的变量。</p><h2 id="_34-es6-中-set-和-map-的原理" tabindex="-1">34. ES6 中 Set 和 Map 的原理 <a class="header-anchor" href="#_34-es6-中-set-和-map-的原理" aria-label="Permalink to &quot;34. ES6 中 Set 和 Map 的原理&quot;">​</a></h2><h3 id="set" tabindex="-1">Set <a class="header-anchor" href="#set" aria-label="Permalink to &quot;Set&quot;">​</a></h3><p><code>Set</code> 是一种集合数据结构，存储唯一值。它使用哈希表来实现快速的成员查找。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">set.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">set.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(set.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre></div><h3 id="map" tabindex="-1">Map <a class="header-anchor" href="#map" aria-label="Permalink to &quot;Map&quot;">​</a></h3><p><code>Map</code> 是一种键值对集合，任何值（对象或基本类型）都可以作为键。它也使用哈希表来实现快速的键值查找。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;age&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Alice</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;age&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="_35-什么是模块化思想" tabindex="-1">35. 什么是模块化思想 <a class="header-anchor" href="#_35-什么是模块化思想" aria-label="Permalink to &quot;35. 什么是模块化思想&quot;">​</a></h2><p>模块化思想是一种软件设计方法，将复杂系统分解为独立、可维护和可重用的模块。</p><h3 id="核心思想" tabindex="-1">核心思想 <a class="header-anchor" href="#核心思想" aria-label="Permalink to &quot;核心思想&quot;">​</a></h3><ol><li><strong>封装</strong>：每个模块封装自己的功能，提供公共接口，隐藏内部实现细节。</li><li><strong>复用性</strong>：模块化鼓励将常用功能封装成独立模块，方便在不同项目中重复使用。</li><li><strong>解耦</strong>：减少模块间依赖关系，降低系统复杂性。</li><li><strong>依赖管理</strong>：明确模块间依赖关系，确保正确加载顺序。</li><li><strong>提高可测试性</strong>：模块化使得单个模块更易于测试。</li></ol><h3 id="另解" tabindex="-1">另解 <a class="header-anchor" href="#另解" aria-label="Permalink to &quot;另解&quot;">​</a></h3><p>模块化思想是一种软件设计和开发的方法论，旨在将复杂的系统分解为独立的、可维护和可重用的模块（或组件）。模块化使得大型应用程序可以被分割成更小、更易于管理的部分，从而提高了代码的可读性、可维护性和可扩展性。</p><p>模块化的核心思想包括以下几个方面：</p><ul><li><p>封装： 每个模块应该封装自己的功能，对外部提供一些公共接口，隐藏内部实现细节。这样可以降低模块间的耦合度，使得模块之间可以独立开发、测试和维护。</p></li><li><p>复用性： 模块化鼓励开发者将常用的功能封装成独立的模块，使得这些功能可以在不同的项目中进行重复使用，避免重复编写相同的代码。</p></li><li><p>解耦： 将系统分解为多个独立的模块可以减少模块之间的依赖关系，降低了整个系统的复杂性。这使得系统的不同部分可以独立开发、测试和维护。(高内聚低耦合，衡量代码是否优秀的标准)</p></li><li><p>依赖管理： 模块化允许开发者明确定义模块之间的依赖关系，这有助于管理项目的依赖并确保正确的加载顺序。</p></li><li><p>提高可测试性： 模块化可以使单个模块更易于测试，因为它们通常有较小的代码量和明确的功能。这有助于更容易编写单元测试和集成测试。</p></li></ul><p>在前端开发中，模块化思想在构建复杂的 Web 应用中尤为重要。常见的前端模块化方案包括 CommonJS、AMD（异步模块定义）、ES6 模块等。这些模块化方案使得开发者可以将前端代码划分为模块，有助于提高代码的组织性、可维护性和可扩展性。</p><h2 id="_36-什么是-javascript-中的事件委托" tabindex="-1">36. 什么是 JavaScript 中的事件委托 <a class="header-anchor" href="#_36-什么是-javascript-中的事件委托" aria-label="Permalink to &quot;36. 什么是 JavaScript 中的事件委托&quot;">​</a></h2><p>事件委托<strong>利用事件冒泡机制，在祖先元素上捕获事件并进行处理，减少事件监听器的数量</strong>。</p><p>事件委托的原理是利用事件冒泡机制。当在子元素上触发事件时，事件会向上冒泡到祖先元素，因此可以在祖先元素上捕获事件并进行处理。这样就不需要为每个子元素都添加事件监听器，而是通过一个事件监听器来处理多个子元素的事件。</p><p>优点和缺点：</p><ul><li>优点：减少事件注册次数，提升性能，因为事件是绑定在父元素上，新加入的子元素同样拥有事件。</li><li>缺点：所有事件都用事件代理，可能会出现事件误判。即本不该被触发的事件被绑定上了事件。</li></ul><h3 id="示例代码-1" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码-1" aria-label="Permalink to &quot;示例代码&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;parentList&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Item 1&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Item 2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Item 3&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> parentList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;parentList&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  parentList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event.target.tagName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;LI&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Clicked on:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.target.textContent);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="_37-你了解构造函数吗-class-是什么-两者有什么区别" tabindex="-1">37. 你了解构造函数吗？class 是什么？两者有什么区别？ <a class="header-anchor" href="#_37-你了解构造函数吗-class-是什么-两者有什么区别" aria-label="Permalink to &quot;37. 你了解构造函数吗？class 是什么？两者有什么区别？&quot;">​</a></h2><h3 id="构造函数-1" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数-1" aria-label="Permalink to &quot;构造函数&quot;">​</a></h3><p>构造函数用于创建对象，通过 <code>new</code> 关键字实例化对象。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> person1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="class" tabindex="-1">class <a class="header-anchor" href="#class" aria-label="Permalink to &quot;class&quot;">​</a></h3><p><code>class</code> 是 ES6 引入的语法糖，用于定义类，提供更清晰的语法。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> person1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li><strong>语法</strong>：<code>class</code> 提供更现代化和直观的语法。</li><li><strong>继承</strong>：<code>class</code> 使用 <code>extends</code> 和 <code>super</code> 关键字实现继承。</li></ul><h2 id="_38-js-的数据类型有哪些-如何判断数据类型-它们的优缺点是什么" tabindex="-1">38. JS 的数据类型有哪些？如何判断数据类型？它们的优缺点是什么？ <a class="header-anchor" href="#_38-js-的数据类型有哪些-如何判断数据类型-它们的优缺点是什么" aria-label="Permalink to &quot;38. JS 的数据类型有哪些？如何判断数据类型？它们的优缺点是什么？&quot;">​</a></h2><h3 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h3><ul><li><strong>基本类型</strong>：number、string、boolean、null、undefined、Symbol、BigInt</li><li><strong>引用类型</strong>：object</li></ul><h3 id="检查数据类型" tabindex="-1">检查数据类型 <a class="header-anchor" href="#检查数据类型" aria-label="Permalink to &quot;检查数据类型&quot;">​</a></h3><ul><li><strong>typeof</strong>：适合基本类型</li><li><strong>constructor</strong>：适合引用类型</li><li><strong>toString</strong>：基本类型和引用类型都可以</li><li><strong>instanceof</strong>：适合引用类型，和原型链有关</li></ul><h2 id="_39-javascript-如何存储-cookie" tabindex="-1">39. JavaScript 如何存储 cookie <a class="header-anchor" href="#_39-javascript-如何存储-cookie" aria-label="Permalink to &quot;39. JavaScript 如何存储 cookie&quot;">​</a></h2><p>利用 <code>document.cookie</code> 进行存储，自定义 name 和 value，添加过期时间和路径。存储的格式是字符串格式。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.cookie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;username=John Doe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="_40-避免回调地狱" tabindex="-1">40. 避免回调地狱 <a class="header-anchor" href="#_40-避免回调地狱" aria-label="Permalink to &quot;40. 避免回调地狱&quot;">​</a></h2><p>避免回调地狱的方法包括<strong>使用 Promise、async/await 等现代异步处理机制</strong>。</p><h3 id="示例-2" tabindex="-1">示例 <a class="header-anchor" href="#示例-2" aria-label="Permalink to &quot;示例&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 Promise</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;api/data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 async/await</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;api/data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h2 id="_41-面对对象和面向过程的区别" tabindex="-1">41. 面对对象和面向过程的区别 <a class="header-anchor" href="#_41-面对对象和面向过程的区别" aria-label="Permalink to &quot;41. 面对对象和面向过程的区别&quot;">​</a></h2><h3 id="面向对象编程-oop" tabindex="-1">面向对象编程（OOP） <a class="header-anchor" href="#面向对象编程-oop" aria-label="Permalink to &quot;面向对象编程（OOP）&quot;">​</a></h3><ul><li><strong>抽象与封装</strong>：强调将现实世界的问题抽象为对象，并将对象的数据和操作封装在一起。对象是数据和操作的组合，可以对外部隐藏内部实现细节，只暴露必要的接口。</li><li><strong>继承</strong>：支持继承，允许创建一个新类，基于现有类的属性和方法进行扩展。继承可以促使代码重用和层次化设计。</li><li><strong>多态性</strong>：允许不同的对象具有相同的接口，但可以表现出不同的行为。这提供了更灵活和可扩展的设计。</li></ul><h3 id="面向过程编程" tabindex="-1">面向过程编程 <a class="header-anchor" href="#面向过程编程" aria-label="Permalink to &quot;面向过程编程&quot;">​</a></h3><ul><li><strong>基于过程</strong>：面向过程编程将程序视为一系列的过程（函数、方法），它们按照顺序执行。程序的主要逻辑由函数组成，函数接受输入并产生输出。</li><li><strong>强调步骤和流程</strong>：面向过程编程更关注问题的解决步骤和控制流程，通常涉及多个函数的调用和数据的传递。</li><li><strong>缺少抽象和封装</strong>：相对于面向对象编程，面向过程编程缺少抽象和封装的特性，函数通常直接操作数据，没有对象的概念。</li></ul><h3 id="区别总结" tabindex="-1">区别总结 <a class="header-anchor" href="#区别总结" aria-label="Permalink to &quot;区别总结&quot;">​</a></h3><ul><li>面向对象编程更强调抽象、封装、继承和多态，以创建更具层次结构和灵活性的代码。</li><li>面向过程编程更强调过程和顺序，适用于较简单的任务和程序。</li><li>实际上，很多编程语言（如 Java、Python、JavaScript 等）都支持面向对象编程和面向过程编程，开发者可以根据问题的复杂性和需求选择适当的编程范式。</li></ul><h2 id="_42-eval" tabindex="-1">42. eval <a class="header-anchor" href="#_42-eval" aria-label="Permalink to &quot;42. eval&quot;">​</a></h2><p><code>eval</code> 是 JavaScript 中的一个全局函数，用于将传递的字符串作为代码进行解析和执行。使用 <code>eval</code> 可以在运行时动态地执行 JavaScript 代码。然而，<code>eval</code> 的使用需要谨慎，因为它可能引发一些安全和性能问题。</p><h3 id="基本语法" tabindex="-1">基本语法 <a class="header-anchor" href="#基本语法" aria-label="Permalink to &quot;基本语法&quot;">​</a></h3><p><code>eval</code> 函数接受一个字符串参数，其中包含要执行的 JavaScript 代码。这段代码会被解析并在当前作用域中执行。</p><h3 id="注意事项和风险" tabindex="-1">注意事项和风险 <a class="header-anchor" href="#注意事项和风险" aria-label="Permalink to &quot;注意事项和风险&quot;">​</a></h3><ul><li><strong>安全风险</strong>：使用 <code>eval</code> 可能会导致安全问题，特别是在执行用户提供的字符串时。</li><li><strong>性能问题</strong>：<code>eval</code> 的使用可能导致解析和执行代码的性能开销增加，因为引擎无法在代码编译阶段进行优化。</li><li><strong>可读性和维护性</strong>：使用 <code>eval</code> 可能会降低代码的可读性和维护性，因为代码的逻辑在运行时才确定。</li></ul><h2 id="_43-proxy" tabindex="-1">43. Proxy <a class="header-anchor" href="#_43-proxy" aria-label="Permalink to &quot;43. Proxy&quot;">​</a></h2><p>在 JavaScript 中，<code>Proxy</code> 是一个内置的对象，它可以用于创建一个代理对象，允许你拦截和自定义目标对象上的各种操作。通过使用 <code>Proxy</code>，你可以监视和控制目标对象的访问、修改和其他行为。<code>Proxy</code> 可以用于实现元编程（Metaprogramming）和创建复杂的拦截逻辑。</p><h3 id="proxy-的基本语法" tabindex="-1">Proxy 的基本语法 <a class="header-anchor" href="#proxy-的基本语法" aria-label="Permalink to &quot;Proxy 的基本语法&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, handler);</span></span></code></pre></div><ul><li><code>target</code>：目标对象，被代理的对象。</li><li><code>handler</code>：一个包含拦截方法的对象，用于定义代理对象的行为。</li></ul><h3 id="示例代码-2" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码-2" aria-label="Permalink to &quot;示例代码&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">property</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Getting property &quot;\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">property</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target[property];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">property</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Setting property &quot;\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">property</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot; to \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    target[property] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, handler);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxy.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 触发 get 拦截</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">proxy.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 触发 set 拦截</span></span></code></pre></div><p><code>Proxy</code> 提供了强大的能力，可以在运行时拦截和控制对象的各种操作。然而，由于 <code>Proxy</code> 可能会引入性能开销，因此在实际应用中需要权衡使用和性能需求。</p><h2 id="_44-什么是-javascript-的严格模式" tabindex="-1">44. 什么是 JavaScript 的严格模式 <a class="header-anchor" href="#_44-什么是-javascript-的严格模式" aria-label="Permalink to &quot;44. 什么是 JavaScript 的严格模式&quot;">​</a></h2><p>通过在代码顶部或函数内部的第一条语句添加 <code>&#39;use strict&#39;;</code>，可以开启严格模式。严格模式的目的是消除一些 JS 的不确定行为，提高代码质量，减少错误，并使代码更具可读性和可维护性。</p><h3 id="严格模式的一些特点和影响包括" tabindex="-1">严格模式的一些特点和影响包括 <a class="header-anchor" href="#严格模式的一些特点和影响包括" aria-label="Permalink to &quot;严格模式的一些特点和影响包括&quot;">​</a></h3><ol><li><strong>禁止使用未声明的变量</strong>：在严格模式下，未声明的变量会导致引用错误。这有助于捕获可能的变量声明问题。</li><li><strong>消除 <code>this</code> 指向全局对象</strong>：在严格模式下，函数内部的 <code>this</code> 不会指向全局对象，而是为 <code>undefined</code>。</li><li><strong>禁止删除变量或函数</strong>：在严格模式下，使用 <code>delete</code> 操作符删除变量、函数或函数的参数会导致语法错误。</li><li><strong>禁止对函数参数重新赋值</strong>：在严格模式下，对函数参数重新赋值会导致语法错误。</li><li><strong>强制 <code>eval</code> 和 <code>arguments</code> 的作用域</strong>：在严格模式下，<code>eval</code> 和 <code>arguments</code> 在其内部会创建一个新的词法作用域，避免与外部作用域冲突。</li><li><strong>禁止八进制字面量</strong>：在严格模式下，不允许使用八进制字面量。</li></ol><h2 id="_45-什么是立即执行函数表达式" tabindex="-1">45. 什么是立即执行函数表达式？ <a class="header-anchor" href="#_45-什么是立即执行函数表达式" aria-label="Permalink to &quot;45. 什么是立即执行函数表达式？&quot;">​</a></h2><p>立即执行函数表达式（IIFE）是一种 JavaScript 中常用的编程模式，用于创建并立即执行一个函数，通常用于创建一个局部作用域，避免变量污染和命名冲突。</p><h3 id="iife-的基本语法" tabindex="-1">IIFE 的基本语法 <a class="header-anchor" href="#iife-的基本语法" aria-label="Permalink to &quot;IIFE 的基本语法&quot;">​</a></h3><p>将函数表达式包裹在括号中，然后紧接着使用另一对括号来立即调用这个函数。</p><h3 id="示例-3" tabindex="-1">示例 <a class="header-anchor" href="#示例-3" aria-label="Permalink to &quot;示例&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 这里是立即执行的函数代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})();</span></span></code></pre></div><h3 id="iife-可以传递参数-并且可以返回值" tabindex="-1">IIFE 可以传递参数，并且可以返回值 <a class="header-anchor" href="#iife-可以传递参数-并且可以返回值" aria-label="Permalink to &quot;IIFE 可以传递参数，并且可以返回值&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 30</span></span></code></pre></div><h3 id="iife-的主要用途包括" tabindex="-1">IIFE 的主要用途包括 <a class="header-anchor" href="#iife-的主要用途包括" aria-label="Permalink to &quot;IIFE 的主要用途包括&quot;">​</a></h3><ul><li><strong>创建私有作用域</strong>：可以用来创建私有的变量作用域，避免变量泄漏到全局作用域中，增加代码的封装性和安全性。</li><li><strong>模块化开发</strong>：可以模拟模块化的行为，将一些功能封装在函数内部，并暴露一些公共接口。</li><li><strong>避免命名冲突</strong>：可以用来避免不同代码块之间的变量命名冲突。</li><li><strong>函数表达式</strong>：可以用来执行一个匿名函数表达式，例如用于设置一些初始化逻辑。</li></ul><h3 id="示例用法" tabindex="-1">示例用法 <a class="header-anchor" href="#示例用法" aria-label="Permalink to &quot;示例用法&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> privateVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;This is private&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> privateFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(privateVar);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在这里可以调用 privateFunction()，但 privateVar 对外不可见</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})();</span></span></code></pre></div><p>虽然 ES6 后的块级作用域（使用 <code>let</code> 和 <code>const</code>）已经减少了 IIFE 在变量作用域方面的必要性，但在某些情况下，IIFE 仍然是一个有用的模式。</p><h2 id="_46-解释-javascript-的单线程和并发模型" tabindex="-1">46. 解释 JavaScript 的单线程和并发模型 <a class="header-anchor" href="#_46-解释-javascript-的单线程和并发模型" aria-label="Permalink to &quot;46. 解释 JavaScript 的单线程和并发模型&quot;">​</a></h2><p>JavaScript 是一种单线程编程语言，这意味着它在任意给定的时刻只能执行一个任务。这与多线程编程语言不同，多线程语言允许同时执行多个任务。</p><h3 id="单线程特性" tabindex="-1">单线程特性 <a class="header-anchor" href="#单线程特性" aria-label="Permalink to &quot;单线程特性&quot;">​</a></h3><p>JavaScript 的单线程特性源自它最初设计用于在浏览器中处理用户交互，操作 DOM，以及执行一些异步任务，如网络请求、定时器等。单线程模型简化了编程和资源管理，避免了一些复杂的多线程问题，如竞态条件和死锁。</p><h3 id="并发模型" tabindex="-1">并发模型 <a class="header-anchor" href="#并发模型" aria-label="Permalink to &quot;并发模型&quot;">​</a></h3><p>虽然 JavaScript 是单线程的，但它仍然可以实现并发（Concurrent）模型，即在有限的资源下，模拟同时执行多个任务。这是通过异步编程、事件循环和回调函数实现的。</p><h3 id="事件循环-event-loop" tabindex="-1">事件循环（Event Loop） <a class="header-anchor" href="#事件循环-event-loop" aria-label="Permalink to &quot;事件循环（Event Loop）&quot;">​</a></h3><p>JavaScript 的并发模型主要依赖于事件循环。事件循环是一个持续运行的机制，用于处理和调度任务。当 JavaScript 遇到异步操作（如网络请求或定时器），它会将这些操作放入任务队列中，然后继续执行后续代码。当主线程空闲时，事件循环会从任务队列中取出一个任务并执行，这样就实现了任务的异步执行。</p><h3 id="回调函数" tabindex="-1">回调函数 <a class="header-anchor" href="#回调函数" aria-label="Permalink to &quot;回调函数&quot;">​</a></h3><p>在 JavaScript 中，常常使用回调函数来处理异步操作的结果。当异步操作完成时，系统会将相应的回调函数放入任务队列中，等待主线程空闲时执行。这使得程序可以在等待异步操作完成的同时继续执行其他任务，从而提高了效率和响应性。</p><p>总结来说，JavaScript 的单线程和并发模型意味着它在任意时刻只能执行一个任务，但通过异步编程和事件循环机制，可以实现在有限资源下同时处理多个任务，从而实现更高效的代码执行和用户交互。</p><h2 id="_47-扩展运算符和-rest-运算符的区别" tabindex="-1">47. 扩展运算符和 rest 运算符的区别 <a class="header-anchor" href="#_47-扩展运算符和-rest-运算符的区别" aria-label="Permalink to &quot;47. 扩展运算符和 rest 运算符的区别&quot;">​</a></h2><h3 id="扩展运算符" tabindex="-1">扩展运算符 <a class="header-anchor" href="#扩展运算符" aria-label="Permalink to &quot;扩展运算符&quot;">​</a></h3><p>扩展运算符用于将一个数组或类数组对象拆分成单独的元素，并在需要多个参数（函数调用、数组、对象等）的地方将这些元素传递给它们。它的语法是三个连续的点号（...）后面跟随一个可迭代对象（如数组、字符串等）。</p><h3 id="rest-运算符" tabindex="-1">rest 运算符 <a class="header-anchor" href="#rest-运算符" aria-label="Permalink to &quot;rest 运算符&quot;">​</a></h3><p>rest 运算符用于将函数参数中的剩余参数收集为一个数组。它的语法是一个三个点号（...）后面跟随参数名。这使得函数可以接受任意数量的参数，并将它们作为数组处理。</p><h3 id="总结区别-1" tabindex="-1">总结区别 <a class="header-anchor" href="#总结区别-1" aria-label="Permalink to &quot;总结区别&quot;">​</a></h3><ul><li><strong>扩展运算符</strong>：用于将一个可迭代对象（数组、字符串等）展开为单独的元素，常用于函数调用或合并数组、对象等。</li><li><strong>rest 运算符</strong>：用于将函数的剩余参数收集为一个数组，使函数能够接受不定数量的参数。它只能在函数参数列表中使用一次。</li></ul><h2 id="_48-使用-const-声明的对象可以直接修改属性吗" tabindex="-1">48. 使用 const 声明的对象可以直接修改属性吗 <a class="header-anchor" href="#_48-使用-const-声明的对象可以直接修改属性吗" aria-label="Permalink to &quot;48. 使用 const 声明的对象可以直接修改属性吗&quot;">​</a></h2><p>使用 <code>const</code> 声明的对象本身是不可重新赋值的，这意味着你不能将一个新的对象赋值给已经使用 <code>const</code> 声明的变量。然而，这并不意味着对象的属性是不可变的。你仍然可以修改使用 <code>const</code> 声明的对象的属性。</p><h3 id="示例-4" tabindex="-1">示例 <a class="header-anchor" href="#示例-4" aria-label="Permalink to &quot;示例&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 31</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 允许修改属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj.age); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 31</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// obj = { name: &quot;Bob&quot; }; // 会报错，不能重新赋值</span></span></code></pre></div><p>所以，虽然你可以修改使用 <code>const</code> 声明的对象的属性，但不能将新对象分配给它。如果你需要完全替换对象，你需要使用 <code>let</code> 或 <code>var</code> 来声明对象，或者使用其他方法来修改现有的 <code>const</code> 对象属性。</p><h2 id="_49-xss-攻击如何预防" tabindex="-1">49. XSS 攻击如何预防？ <a class="header-anchor" href="#_49-xss-攻击如何预防" aria-label="Permalink to &quot;49. XSS 攻击如何预防？&quot;">​</a></h2><p>XSS（跨站脚本攻击）是一种常见的安全漏洞，攻击者通过在网页中注入恶意脚本来窃取用户信息或执行其他恶意操作。预防 XSS 攻击的方法包括：</p><h3 id="预防措施" tabindex="-1">预防措施 <a class="header-anchor" href="#预防措施" aria-label="Permalink to &quot;预防措施&quot;">​</a></h3><ol><li><strong>输入验证和清理</strong>：对用户输入进行严格的验证和清理，避免恶意代码注入。使用白名单过滤和正则表达式来确保输入的合法性。</li><li><strong>输出编码</strong>：对输出到网页的内容进行编码处理，防止恶意脚本执行。常用的编码方法包括 HTML 编码、JavaScript 编码和 URL 编码。</li><li><strong>使用安全的库和框架</strong>：使用经过安全审查的库和框架，它们通常会内置防范 XSS 攻击的机制。例如，React、Angular 和 Vue.js 等前端框架都有防止 XSS 的措施。</li><li><strong>内容安全策略（CSP）</strong>：配置内容安全策略，通过 HTTP 头部指令来限制网页可以加载的资源，防止恶意脚本的执行。</li><li><strong>避免直接操作 DOM</strong>：尽量避免直接操作 DOM，使用安全的 API 和框架来更新页面内容。</li><li><strong>HTTP-only 和 Secure Cookie</strong>：设置 HTTP-only 和 Secure 属性的 Cookie，防止客户端脚本访问敏感信息。</li></ol><p>通过以上措施，可以有效预防 XSS 攻击，保护用户数据和应用的安全。</p><h2 id="_50-post-和-get-的区别" tabindex="-1">50. POST 和 GET 的区别 <a class="header-anchor" href="#_50-post-和-get-的区别" aria-label="Permalink to &quot;50. POST 和 GET 的区别&quot;">​</a></h2><ol><li><strong>语义化</strong>：GET 本意是获取，POST 是传输的意思。</li><li><strong>安全性</strong>：GET 拼接在地址栏后面，不安全，而且可以在地址栏进行改变。</li><li><strong>长度性</strong>：GET 拼接在地址栏后面，地址栏支持 2000 多个字符，但是 POST 支持 4KB（理论可以配置）。</li><li><strong>传输性</strong>：GET 不需要设置请求头，POST 设置请求头，同时放到 <code>send</code> 方法中进行传输。</li><li><strong>缓存性</strong>：GET 有缓存，POST 没有缓存。</li></ol><h2 id="_51-promise-的-race-和-all-的区别" tabindex="-1">51. Promise 的 race 和 all 的区别 <a class="header-anchor" href="#_51-promise-的-race-和-all-的区别" aria-label="Permalink to &quot;51. Promise 的 race 和 all 的区别&quot;">​</a></h2><ul><li><code>Promise.race(iterable)</code> 方法接受一个可迭代对象（如数组）作为参数，并返回一个新的 Promise。这个新 Promise 将会在参数中的任何一个 Promise 解决（fulfilled）或拒绝（rejected）时立即解决或拒绝，以第一个完成的 Promise 的状态为准。换句话说，<strong>只要有一个 Promise 完成（无论是解决还是拒绝），<code>Promise.race()</code> 就会立即返回</strong>。（哪个快就返回哪个，race）</li><li><code>Promise.all(iterable)</code> 方法接受一个可迭代对象（如数组）作为参数，并返回一个新的 Promise。这个新 Promise 将会在参数中的所有 Promise 都解决时才会解决，且它的解决值是一个数组，包含了参数中所有 Promise 的解决值，顺序与参数中的 Promise 顺序一致。如果<strong>任何一个 Promise 被拒绝，那么 <code>Promise.all()</code> 会立即拒绝，并将第一个拒绝的 Promise 的原因作为拒绝原因</strong>。（要都满足，all）</li></ul><h3 id="总结区别-2" tabindex="-1">总结区别 <a class="header-anchor" href="#总结区别-2" aria-label="Permalink to &quot;总结区别&quot;">​</a></h3><ul><li><code>Promise.race()</code> 用于比较多个 Promise 中哪个首先解决或拒绝，只要有一个完成，整个 <code>Promise.race()</code> 就会完成。</li><li><code>Promise.all()</code> 用于等待所有 Promise 都完成，然后将它们的解决值作为数组返回，或者如果有任何一个 Promise 被拒绝，则整个 <code>Promise.all()</code> 会被拒绝。</li></ul><h2 id="_52-判断打印顺序-promise-settimeout-async-await" tabindex="-1">52. 判断打印顺序（Promise，setTimeout，async，await） <a class="header-anchor" href="#_52-判断打印顺序-promise-settimeout-async-await" aria-label="Permalink to &quot;52. 判断打印顺序（Promise，setTimeout，async，await）&quot;">​</a></h2><p>在 JavaScript 中，当涉及到 Promise、setTimeout、async 和 await 时，它们的执行顺序可能会有所不同。下面是一个基本的示例，展示了它们的执行顺序：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> promise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Promise Start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Promise Resolved&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> asyncFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Async Function Start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> promise;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Async Function End&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Script Start&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">promise.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Promise .then&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asyncFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setTimeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Script End&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="_53-promise-catch-能捕获-settimeout-的错误吗" tabindex="-1">53. Promise.catch 能捕获 setTimeout 的错误吗 <a class="header-anchor" href="#_53-promise-catch-能捕获-settimeout-的错误吗" aria-label="Permalink to &quot;53. Promise.catch 能捕获 setTimeout 的错误吗&quot;">​</a></h2><p>setTimeout 不返回 Promise</p><p><code>Promise.catch</code> 是用于捕获 Promise 链中出现的错误的方法，它可以捕获到由 <code>reject</code> 传递的错误。然而，对于 <code>setTimeout</code> 的错误，<code>Promise.catch</code> 并不能直接捕获，因为 <code>setTimeout</code> 不是 Promise。</p><p>**当在 <code>setTimeout</code> 中发生错误时，该错误不会传递到 Promise 链中，因此 <code>Promise.catch</code> 无法捕获它。**但是，你可以使用 <code>try...catch</code> 块来捕获 <code>setTimeout</code> 内部的错误，然后通过一个 Promise 来处理错误，从而使错误能够在 Promise 链中被捕获。</p><h3 id="示例-5" tabindex="-1">示例 <a class="header-anchor" href="#示例-5" aria-label="Permalink to &quot;示例&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> delayedError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 在这里抛出一个错误</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Error inside setTimeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">delayedError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 不会执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Resolved&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 输出: Caught error: Error inside setTimeout</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Caught error:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error.message);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span></code></pre></div><p>在这个示例中，<code>setTimeout</code> 内部发生的错误会被捕获并通过 <code>reject</code> 传递到 Promise 链中，然后在 <code>catch</code> 中进行处理。</p><p>需要注意的是，<code>setTimeout</code> 内部的错误处理需要在 <code>try...catch</code> 块中完成，否则错误将会传播到全局作用域，导致无法捕获。</p><h2 id="_54-基本数据类型跟引用数据类型区别" tabindex="-1">54. 基本数据类型跟引用数据类型区别 <a class="header-anchor" href="#_54-基本数据类型跟引用数据类型区别" aria-label="Permalink to &quot;54. 基本数据类型跟引用数据类型区别&quot;">​</a></h2><p>在 JavaScript 中，数据类型分为基本数据类型和引用数据类型。它们在内存中的存储和操作方式有一些重要的区别。</p><h3 id="基本数据类型" tabindex="-1">基本数据类型 <a class="header-anchor" href="#基本数据类型" aria-label="Permalink to &quot;基本数据类型&quot;">​</a></h3><ul><li><strong>数字（Number）</strong>：用于表示整数和浮点数，例如：42, 3.14。</li><li><strong>字符串（String）</strong>：用于表示文本，例如：&quot;Hello, world!&quot;。</li><li><strong>布尔值（Boolean）</strong>：表示真（true）或假（false）。</li><li><strong>空值（Null）</strong>：表示一个没有值的特殊值。</li><li><strong>未定义（Undefined）</strong>：表示一个未初始化的变量。</li><li><strong>符号（Symbol）</strong>：在 ES6 中引入的数据类型，表示唯一的、不可变的值。</li><li><strong>大整数（BigInt）</strong>：ES2020 引入了一种新的数据类型 BigInt（大整数），这是 ES 的第八种数据类型。</li></ul><h3 id="基本数据类型的特点" tabindex="-1">基本数据类型的特点 <a class="header-anchor" href="#基本数据类型的特点" aria-label="Permalink to &quot;基本数据类型的特点&quot;">​</a></h3><ul><li>存储在栈（Stack）内存中。</li><li>在复制变量值时，会复制变量的实际值。</li><li>值是不可变的，无法被修改。</li></ul><h3 id="引用数据类型" tabindex="-1">引用数据类型 <a class="header-anchor" href="#引用数据类型" aria-label="Permalink to &quot;引用数据类型&quot;">​</a></h3><ul><li><strong>对象（Object）</strong>：表示一组键值对的集合，例如：对象字面量 <code>{}</code>、<code>new Object()</code>、数组、函数等。</li><li><strong>数组（Array）</strong>：一种特殊的对象，用于存储有序的数据列表。</li><li><strong>函数（Function）</strong>：一种特殊的对象，具有可执行的代码块。</li><li><strong>日期（Date）</strong>：表示日期和时间的对象。</li><li><strong>正则表达式（RegExp）</strong>：表示文本匹配模式的对象。</li></ul><h3 id="引用数据类型的特点" tabindex="-1">引用数据类型的特点 <a class="header-anchor" href="#引用数据类型的特点" aria-label="Permalink to &quot;引用数据类型的特点&quot;">​</a></h3><ul><li>存储在堆（Heap）内存中。</li><li>在复制变量值时，复制的是指向对象的引用，而不是对象本身。</li><li>值是可变的，可以通过引用进行修改。</li></ul><p>由于引用数据类型存储在堆内存中，它们的操作和传递会涉及更多的内存开销，而基本数据类型则存储在栈内存中，更适合存储简单的数据。</p><p>需要注意的是，JavaScript 中的数据类型有时可能会表现得不太符合预期，特别是在涉及隐式类型转换和一些特殊操作时。理解这些基本概念有助于更好地理解数据在 JavaScript 中的处理方式。</p><h2 id="_55-栈堆怎么使用" tabindex="-1">55. 栈堆怎么使用 <a class="header-anchor" href="#_55-栈堆怎么使用" aria-label="Permalink to &quot;55. 栈堆怎么使用&quot;">​</a></h2><p>JavaScript 中的栈和堆是内存管理的两个重要概念，它们分别用于存储不同类型的数据。</p><h3 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h3><p>栈是一种线性数据结构，遵循&quot;后进先出&quot;的原则。在 JavaScript 中，栈主要用于存储函数的调用信息和基本数据类型的值。当一个函数被调用时，会创建一个称为&quot;调用帧&quot;或&quot;执行上下文&quot;的数据结构，用于存储该函数的局部变量、参数等信息。当函数执行完毕时，相关的调用帧会从栈中移除。</p><p>栈主要用于处理函数调用、变量的声明和基本数据类型的存储，比如数字、字符串、布尔值等。</p><h3 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to &quot;堆&quot;">​</a></h3><p>堆是一种动态分配的内存区域，用于存储引用数据类型的对象，如对象、数组、函数等。堆中的数据存储没有固定的顺序，可以通过引用相互连接。</p><p>堆主要用于存储动态创建的对象，它们的大小可以在运行时改变，也就是说，堆中的内存需要手动进行分配和释放。JavaScript 引擎会负责管理堆内存的分配和释放，通常使用垃圾回收机制来处理不再使用的对象。</p><p>在 JavaScript 中，你不需要直接操作栈和堆，因为内存管理通常由 JavaScript 引擎自动处理。你只需要关注如何使用变量、对象、函数等，并确保正确地使用它们即可。当你声明变量、创建对象、调用函数等时，JavaScript 引擎会自动分配和管理内存，以确保代码正确运行并且不造成内存泄漏等问题。</p><h2 id="_56-this-指向" tabindex="-1">56. this 指向 <a class="header-anchor" href="#_56-this-指向" aria-label="Permalink to &quot;56. this 指向&quot;">​</a></h2><p><code>this</code> 关键字在 JavaScript 中的指向是动态的，取决于它的调用环境。以下是一些常见的 <code>this</code> 指向情况：</p><ol><li><p><strong>全局环境</strong>：在全局环境中，<code>this</code> 指向全局对象（浏览器中是 <code>window</code>，Node.js 中是 <code>global</code>）。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在浏览器中，输出 window 对象</span></span></code></pre></div></li><li><p><strong>函数调用</strong>：在普通函数调用中，<code>this</code> 指向全局对象（在严格模式下，<code>this</code> 为 <code>undefined</code>）。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在浏览器中，输出 window 对象</span></span></code></pre></div></li><li><p><strong>方法调用</strong>：当函数作为对象的方法调用时，<code>this</code> 指向调用该方法的对象。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;Alice&#39;</span></span></code></pre></div></li><li><p><strong>构造函数调用</strong>：使用 <code>new</code> 关键字调用构造函数时，<code>this</code> 指向新创建的实例对象。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;Bob&#39;</span></span></code></pre></div></li><li><p><strong>箭头函数</strong>：箭头函数不绑定自己的 <code>this</code>，它会捕获其所在上下文的 <code>this</code> 值。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 undefined，因为箭头函数的 this 指向全局对象</span></span></code></pre></div></li><li><p><strong><code>call</code>、<code>apply</code> 和 <code>bind</code></strong>：可以显式地设置 <code>this</code> 的指向。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Charlie&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">greet.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;Charlie&#39;</span></span></code></pre></div></li></ol><h2 id="_57-手写一个-bind" tabindex="-1">57. 手写一个 bind <a class="header-anchor" href="#_57-手写一个-bind" aria-label="Permalink to &quot;57. 手写一个 bind&quot;">​</a></h2><p><code>bind</code> 方法用于创建一个新的函数，该函数在调用时会将指定的上下文（<code>this</code> 值）绑定到预先定义的值，并可传递参数。以下是一个手写的简化版 <code>bind</code> 方法实现：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 手写的简化版 bind 方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myBind</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> originalFunction</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用 myBind 的原函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">innerArgs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> originalFunction.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, args.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">concat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(innerArgs));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> person</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}, \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boundGreet</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> greet.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">myBind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(person, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">boundGreet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: Hello, John</span></span></code></pre></div><h2 id="_58-面向对象的继承" tabindex="-1">58. 面向对象的继承 <a class="header-anchor" href="#_58-面向对象的继承" aria-label="Permalink to &quot;58. 面向对象的继承&quot;">​</a></h2><p>在 JavaScript 中，面向对象的继承是通过原型链来实现的。JavaScript 使用原型链来实现对象之间的继承关系，使一个对象可以继承另一个对象的属性和方法。以下是一些常见的继承方式：</p><h3 id="原型链继承" tabindex="-1">原型链继承 <a class="header-anchor" href="#原型链继承" aria-label="Permalink to &quot;原型链继承&quot;">​</a></h3><p>这是 JavaScript 中最基本的继承方式，它利用原型链实现对象之间的继承。子类的原型（prototype）指向父类的一个实例，从而继承了父类的属性和方法。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHello</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Hello, my name is \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 原型链继承</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> childObj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">childObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以调用父类的方法</span></span></code></pre></div><h3 id="构造函数继承-借用构造函数" tabindex="-1">构造函数继承（借用构造函数） <a class="header-anchor" href="#构造函数继承-借用构造函数" aria-label="Permalink to &quot;构造函数继承（借用构造函数）&quot;">​</a></h3><p>在子类构造函数内部调用父类构造函数，以获取父类的属性。这种方式实现了属性的继承，但不能继承父类原型上的方法。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Parent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 借用构造函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> childObj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(childObj.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以访问父类属性</span></span></code></pre></div><h3 id="组合继承-原型链继承-构造函数继承" tabindex="-1">组合继承（原型链继承 + 构造函数继承） <a class="header-anchor" href="#组合继承-原型链继承-构造函数继承" aria-label="Permalink to &quot;组合继承（原型链继承 + 构造函数继承）&quot;">​</a></h3><p>这种方式结合了原型链继承和构造函数继承，既继承了父类原型上的方法，又继承了父类的属性。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHello</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Hello, my name is \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Parent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 借用构造函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 原型链继承</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> childObj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Charlie&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">childObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以调用父类的方法</span></span></code></pre></div><h3 id="es6-class-继承" tabindex="-1">ES6 Class 继承 <a class="header-anchor" href="#es6-class-继承" aria-label="Permalink to &quot;ES6 Class 继承&quot;">​</a></h3><p>ES6 引入了 Class 语法糖，使得继承更加直观和易用。使用 <code>extends</code> 关键字可以创建一个子类，子类可以继承父类的属性和方法。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  sayHello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Hello, my name is \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用父类构造函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> childObj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;David&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">childObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以调用父类的方法</span></span></code></pre></div><p>在选择继承方式时，需要根据具体情况来决定使用哪种方法。每种继承方式都有其优缺点，考虑继承链的深度、属性和方法的继承需求等因素是很重要的。</p><h2 id="_59-如何对一个数组过滤-如何找到数组中符合的第一个数据" tabindex="-1">59. 如何对一个数组过滤，如何找到数组中符合的第一个数据？ <a class="header-anchor" href="#_59-如何对一个数组过滤-如何找到数组中符合的第一个数据" aria-label="Permalink to &quot;59. 如何对一个数组过滤，如何找到数组中符合的第一个数据？&quot;">​</a></h2><p>在 JavaScript 中，你可以使用 <code>filter</code> 方法来过滤一个数组，并使用 <code>find</code> 方法来查找数组中符合条件的第一个元素。</p><h3 id="使用-filter-方法过滤数组" tabindex="-1">使用 <code>filter</code> 方法过滤数组 <a class="header-anchor" href="#使用-filter-方法过滤数组" aria-label="Permalink to &quot;使用 \`filter\` 方法过滤数组&quot;">​</a></h3><p><code>filter</code> 方法创建一个新数组，其中包含所有满足指定条件的原始数组元素。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> numbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 过滤出所有偶数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> evenNumbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(evenNumbers); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: [2, 4, 6, 8]</span></span></code></pre></div><h3 id="使用-find-方法查找第一个符合条件的元素" tabindex="-1">使用 <code>find</code> 方法查找第一个符合条件的元素 <a class="header-anchor" href="#使用-find-方法查找第一个符合条件的元素" aria-label="Permalink to &quot;使用 \`find\` 方法查找第一个符合条件的元素&quot;">​</a></h3><p><code>find</code> 方法返回数组中第一个满足条件的元素。如果找不到满足条件的元素，则返回 <code>undefined</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fruits</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;apple&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;banana&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;orange&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;grape&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;kiwi&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 找到第一个长度大于 5 的水果</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> firstLongFruit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fruits.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fruit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fruit.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(firstLongFruit); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: &#39;banana&#39;</span></span></code></pre></div><p>需要注意的是，<code>filter</code> 和 <code>find</code> 方法都不会修改原始数组，而是返回一个新的数组或元素。这些方法是对数组进行常见操作的强大工具，可以根据需要进行灵活的过滤和查找操作。</p><h2 id="_60-如果有两个-1000-个值的数组-找出相同的值怎么实现" tabindex="-1">60. 如果有两个 1000 个值的数组，找出相同的值怎么实现？ <a class="header-anchor" href="#_60-如果有两个-1000-个值的数组-找出相同的值怎么实现" aria-label="Permalink to &quot;60. 如果有两个 1000 个值的数组，找出相同的值怎么实现？&quot;">​</a></h2><h3 id="使用集合-set" tabindex="-1">使用集合（Set） <a class="header-anchor" href="#使用集合-set" aria-label="Permalink to &quot;使用集合（Set）&quot;">​</a></h3><p>要在 JavaScript 中找到两个数组中相同的值，可以使用多种方法。这里介绍一种高效的方法，使用 <code>Set</code> 数据结构来实现。</p><ol><li>将其中一个数组的所有元素存储在一个 <code>Set</code> 中。</li><li>遍历另一个数组，并检查每个元素是否在 <code>Set</code> 中。</li><li>如果元素在 <code>Set</code> 中，则将其添加到结果数组中。</li></ol><p>这种方法的时间复杂度为 (O(n))，其中 (n) 是数组的长度，因为 <code>Set</code> 提供了平均 (O(1)) 的查找时间。</p><h3 id="示例代码-3" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码-3" aria-label="Permalink to &quot;示例代码&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findCommonElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arr2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 将第一个数组的所有元素存储在一个 Set 中</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> set1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arr1);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 用于存储相同的值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> commonElements</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 遍历第二个数组，查找相同的值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr2) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (set1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      commonElements.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(element);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> commonElements;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 示例数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> array1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* ... 1000 个值 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> array2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">14</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* ... 1000 个值 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 找出相同的值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> findCommonElements</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array1, array2);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result);</span></span></code></pre></div><h3 id="解释" tabindex="-1">解释 <a class="header-anchor" href="#解释" aria-label="Permalink to &quot;解释&quot;">​</a></h3><ol><li><strong>创建 Set</strong>：<code>const set1 = new Set(arr1);</code> 将第一个数组的所有元素存储在一个 <code>Set</code> 中。这样可以快速查找元素是否存在。</li><li><strong>遍历第二个数组</strong>：<code>for (const element of arr2)</code> 遍历第二个数组的每个元素。</li><li><strong>检查元素是否在 Set 中</strong>：<code>if (set1.has(element))</code> 检查元素是否在 <code>Set</code> 中，如果在，则将其添加到 <code>commonElements</code> 数组中。</li><li><strong>返回结果</strong>：<code>return commonElements;</code> 返回包含相同值的数组。</li></ol><p>这种方法的优点是时间复杂度较低，适合处理大规模数据集。</p><h2 id="_61-map、foreach-和-filter-的区别" tabindex="-1">61. <code>map</code>、<code>forEach</code> 和 <code>filter</code> 的区别 <a class="header-anchor" href="#_61-map、foreach-和-filter-的区别" aria-label="Permalink to &quot;61. \`map\`、\`forEach\` 和 \`filter\` 的区别&quot;">​</a></h2><p><code>map</code>、<code>forEach</code> 和 <code>filter</code> 是 JavaScript 数组提供的三个常用方法，用于对数组进行遍历和转换。它们的主要区别在于它们的用途和返回值。</p><h3 id="map-方法" tabindex="-1"><code>map</code> 方法 <a class="header-anchor" href="#map-方法" aria-label="Permalink to &quot;\`map\` 方法&quot;">​</a></h3><p><code>map</code> 方法用于对数组的每个元素都执行一个指定的操作，然后返回一个新的数组，新数组的每个元素是操作后的结果。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> numbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> doubled</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(doubled); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: [2, 4, 6, 8, 10]</span></span></code></pre></div><h3 id="foreach-方法" tabindex="-1"><code>forEach</code> 方法 <a class="header-anchor" href="#foreach-方法" aria-label="Permalink to &quot;\`forEach\` 方法&quot;">​</a></h3><p><code>forEach</code> 方法用于对数组的每个元素执行一个操作，但它不返回新的数组。它主要用于遍历数组并对每个元素进行副作用操作，例如打印、更新等。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> numbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 2, 4, 6, 8, 10</span></span></code></pre></div><h3 id="filter-方法" tabindex="-1"><code>filter</code> 方法 <a class="header-anchor" href="#filter-方法" aria-label="Permalink to &quot;\`filter\` 方法&quot;">​</a></h3><p><code>filter</code> 方法用于筛选数组中满足指定条件的元素，然后返回一个新的数组，新数组包含满足条件的元素。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> numbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> evenNumbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numbers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(evenNumbers); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: [2, 4]</span></span></code></pre></div><h3 id="综合来说" tabindex="-1">综合来说 <a class="header-anchor" href="#综合来说" aria-label="Permalink to &quot;综合来说&quot;">​</a></h3><p>这些方法的区别在于它们的用途和返回值：</p><ul><li><code>map</code> 用于映射每个元素到一个新值，返回新数组。</li><li><code>forEach</code> 用于遍历数组并执行操作，没有返回值。</li><li><code>filter</code> 用于筛选满足条件的元素，返回新数组。</li></ul><h2 id="_62-浏览器缓存存在哪里" tabindex="-1">62. 浏览器缓存存在哪里？ <a class="header-anchor" href="#_62-浏览器缓存存在哪里" aria-label="Permalink to &quot;62. 浏览器缓存存在哪里？&quot;">​</a></h2><h3 id="http-缓存-浏览器缓存" tabindex="-1">HTTP 缓存（浏览器缓存） <a class="header-anchor" href="#http-缓存-浏览器缓存" aria-label="Permalink to &quot;HTTP 缓存（浏览器缓存）&quot;">​</a></h3><p>浏览器会将从服务器获取的资源（如 HTML、CSS、JavaScript、图像等）存储在本地缓存中，以便在后续访问相同页面时可以直接从缓存中加载，而不必再次向服务器发出请求。HTTP 缓存分为两种类型：强缓存和协商缓存。</p><ul><li><strong>强缓存</strong>：浏览器在一定时间内直接使用本地缓存，不发出请求。常见的头部信息有 <code>Cache-Control</code> 和 <code>Expires</code>。</li><li><strong>协商缓存</strong>：浏览器会向服务器发出请求，询问是否可以使用缓存，服务器会判断是否需要重新返回资源。常见的头部信息有 <code>Last-Modified</code> 和 <code>ETag</code>。</li></ul><h3 id="localstorage-和-sessionstorage" tabindex="-1">LocalStorage 和 SessionStorage <a class="header-anchor" href="#localstorage-和-sessionstorage" aria-label="Permalink to &quot;LocalStorage 和 SessionStorage&quot;">​</a></h3><p><code>localStorage</code> 和 <code>sessionStorage</code> 是浏览器提供的本地存储方案，用于在浏览器关闭后依然保留数据。<code>localStorage</code> 存储数据没有过期时间，而 <code>sessionStorage</code> 存储的数据在会话结束（浏览器关闭）后会被清除。</p><h3 id="cookies" tabindex="-1">Cookies <a class="header-anchor" href="#cookies" aria-label="Permalink to &quot;Cookies&quot;">​</a></h3><p>Cookies 是在浏览器和服务器之间传递的小型数据片段，用于存储用户信息、会话状态等。Cookies 通常具有过期时间，可以在客户端和服务器之间进行数据交换。</p><h2 id="_63-http-1-0-和-http-2-0-的区别-计网-流水线" tabindex="-1">63. HTTP/1.0 和 HTTP/2.0 的区别（计网，流水线） <a class="header-anchor" href="#_63-http-1-0-和-http-2-0-的区别-计网-流水线" aria-label="Permalink to &quot;63. HTTP/1.0 和 HTTP/2.0 的区别（计网，流水线）&quot;">​</a></h2><p>HTTP/2 相对于 HTTP/1.0 在性能方面有显著的改进，特别是在减少延迟、提高并发性和减少资源浪费方面。这些改进使得网页加载更快、响应更迅速，特别是在复杂的网络环境中。</p><p>HTTP/1.0 和 HTTP/2.0 是两个不同版本的超文本传输协议（HTTP），它们之间有许多显著的区别。以下是一些主要的区别：</p><h3 id="_1-连接复用" tabindex="-1">1. <strong>连接复用</strong> <a class="header-anchor" href="#_1-连接复用" aria-label="Permalink to &quot;1. **连接复用**&quot;">​</a></h3><ul><li><strong>HTTP/1.0</strong>：每个请求/响应对使用一个单独的 TCP 连接。这意味着每次请求都需要建立和关闭连接，增加了延迟和开销。</li><li><strong>HTTP/2.0</strong>：引入了连接复用（Multiplexing），允许多个请求和响应通过单个 TCP 连接并行传输，减少了延迟和连接开销。</li></ul><h3 id="_2-头部压缩" tabindex="-1">2. <strong>头部压缩</strong> <a class="header-anchor" href="#_2-头部压缩" aria-label="Permalink to &quot;2. **头部压缩**&quot;">​</a></h3><ul><li><strong>HTTP/1.0</strong>：HTTP 头部未经压缩，且每个请求/响应对都包含完整的头部信息，导致头部冗余和传输效率低下。</li><li><strong>HTTP/2.0</strong>：使用 HPACK 压缩算法对头部信息进行压缩，减少了头部大小，提高了传输效率。</li></ul><h3 id="_3-二进制协议" tabindex="-1">3. <strong>二进制协议</strong> <a class="header-anchor" href="#_3-二进制协议" aria-label="Permalink to &quot;3. **二进制协议**&quot;">​</a></h3><ul><li><strong>HTTP/1.0</strong>：是基于文本的协议，所有的请求和响应都是以文本形式传输的。</li><li><strong>HTTP/2.0</strong>：是基于二进制的协议，所有的帧（Frame）都以二进制格式传输，这使得协议解析更加高效和可靠。</li></ul><h3 id="_4-流-stream" tabindex="-1">4. <strong>流（Stream）</strong> <a class="header-anchor" href="#_4-流-stream" aria-label="Permalink to &quot;4. **流（Stream）**&quot;">​</a></h3><ul><li><strong>HTTP/1.0</strong>：没有流的概念，每个请求/响应对是独立的。</li><li><strong>HTTP/2.0</strong>：引入了流的概念，每个 TCP 连接可以包含多个流，每个流都有唯一的标识符，可以并行处理多个请求和响应。</li></ul><h3 id="_5-服务器推送-server-push" tabindex="-1">5. <strong>服务器推送（Server Push）</strong> <a class="header-anchor" href="#_5-服务器推送-server-push" aria-label="Permalink to &quot;5. **服务器推送（Server Push）**&quot;">​</a></h3><ul><li><strong>HTTP/1.0</strong>：没有服务器推送的功能。</li><li><strong>HTTP/2.0</strong>：支持服务器推送功能，服务器可以在客户端请求之前主动推送资源到客户端，减少延迟。</li></ul><h3 id="_6-优先级和依赖" tabindex="-1">6. <strong>优先级和依赖</strong> <a class="header-anchor" href="#_6-优先级和依赖" aria-label="Permalink to &quot;6. **优先级和依赖**&quot;">​</a></h3><ul><li><strong>HTTP/1.0</strong>：没有优先级和依赖的机制。</li><li><strong>HTTP/2.0</strong>：引入了优先级和依赖机制，客户端可以为每个流指定优先级，服务器可以根据优先级处理请求，提高资源利用率和响应速度。</li></ul><h3 id="_7-请求-响应模型" tabindex="-1">7. <strong>请求/响应模型</strong> <a class="header-anchor" href="#_7-请求-响应模型" aria-label="Permalink to &quot;7. **请求/响应模型**&quot;">​</a></h3><ul><li><strong>HTTP/1.0</strong>：严格的请求/响应模型，每个请求必须等待上一个请求完成后才能发送下一个请求。</li><li><strong>HTTP/2.0</strong>：允许请求和响应的并行处理，通过多路复用和流的机制，可以同时发送多个请求和接收多个响应。</li></ul><h3 id="总结-2" tabindex="-1">总结 <a class="header-anchor" href="#总结-2" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>HTTP/2.0 相较于 HTTP/1.0 在性能和效率方面有了显著的提升，主要通过连接复用、头部压缩、二进制传输、流、服务器推送和优先级等机制来减少延迟、提高传输效率和资源利用率。这些改进使得 HTTP/2.0 更适合现代 Web 应用的需求。</p><h2 id="_64-相关算法" tabindex="-1">64. 相关算法 <a class="header-anchor" href="#_64-相关算法" aria-label="Permalink to &quot;64. 相关算法&quot;">​</a></h2><h3 id="深浅拷贝" tabindex="-1">深浅拷贝 <a class="header-anchor" href="#深浅拷贝" aria-label="Permalink to &quot;深浅拷贝&quot;">​</a></h3><h4 id="浅拷贝" tabindex="-1">浅拷贝 <a class="header-anchor" href="#浅拷贝" aria-label="Permalink to &quot;浅拷贝&quot;">​</a></h4><p>浅拷贝只复制对象的引用，而不复制对象本身。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assign</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({}, obj1);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj2); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: { a: 1, b: 2 }</span></span></code></pre></div><h4 id="深拷贝" tabindex="-1">深拷贝 <a class="header-anchor" href="#深拷贝" aria-label="Permalink to &quot;深拷贝&quot;">​</a></h4><p>深拷贝会递归地复制对象及其子对象。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b: { c: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj1));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj2); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: { a: 1, b: { c: 2 } }</span></span></code></pre></div><h3 id="数组去重" tabindex="-1">数组去重 <a class="header-anchor" href="#数组去重" aria-label="Permalink to &quot;数组去重&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> uniqueArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array)];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uniqueArray); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: [1, 2, 3, 4, 5]</span></span></code></pre></div><h3 id="数组扁平化" tabindex="-1">数组扁平化 <a class="header-anchor" href="#数组扁平化" aria-label="Permalink to &quot;数组扁平化&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nestedArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> flatArray</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nestedArray.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">flat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Infinity</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flatArray); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: [1, 2, 3, 4, 5]</span></span></code></pre></div><h3 id="数组排序" tabindex="-1">数组排序 <a class="header-anchor" href="#数组排序" aria-label="Permalink to &quot;数组排序&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(array); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: [1, 1, 3, 4, 5, 9]</span></span></code></pre></div><h3 id="函数的防抖和节流" tabindex="-1">函数的防抖和节流 <a class="header-anchor" href="#函数的防抖和节流" aria-label="Permalink to &quot;函数的防抖和节流&quot;">​</a></h3><p>防抖（Debounce）和节流（Throttle）是两种常见的性能优化技术，主要用于控制高频率事件的触发次数，以减少不必要的计算和资源消耗。它们在处理诸如滚动、窗口调整大小、输入框输入等频繁触发的事件时非常有用。</p><h3 id="防抖-debounce" tabindex="-1">防抖（Debounce） <a class="header-anchor" href="#防抖-debounce" aria-label="Permalink to &quot;防抖（Debounce）&quot;">​</a></h3><p>防抖的原理是将多次触发的事件合并为一次，在事件触发后的一段时间内如果没有再次触发事件，则执行事件处理函数。如果在这段时间内再次触发事件，则重新开始计时。</p><h4 id="使用场景-1" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景-1" aria-label="Permalink to &quot;使用场景&quot;">​</a></h4><ul><li>搜索框输入：用户停止输入后再进行搜索请求，以减少不必要的请求次数。</li><li>窗口调整大小：用户停止调整窗口大小后再进行计算和布局调整。</li></ul><h4 id="示例代码-4" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码-4" aria-label="Permalink to &quot;示例代码&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeout;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timeout);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(context, args), wait);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handleResize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;窗口调整大小&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;resize&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handleResize);</span></span></code></pre></div><h3 id="节流-throttle" tabindex="-1">节流（Throttle） <a class="header-anchor" href="#节流-throttle" aria-label="Permalink to &quot;节流（Throttle）&quot;">​</a></h3><p>节流的原理是限制一个函数在一定时间内只能执行一次，即使在这段时间内事件被多次触发，函数也只会执行一次。节流可以通过定时器或时间戳来实现。</p><h4 id="使用场景-2" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景-2" aria-label="Permalink to &quot;使用场景&quot;">​</a></h4><ul><li>滚动事件：限制滚动事件处理函数的执行频率，以减少滚动时的计算量。</li><li>按钮点击：防止按钮被连续点击多次，导致多次触发事件。</li></ul><h4 id="示例代码-5" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码-5" aria-label="Permalink to &quot;示例代码&quot;">​</a></h4><p><strong>使用时间戳实现节流</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> previous </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> now</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> previous </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wait) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      previous </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handleScroll</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;滚动事件&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;scroll&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handleScroll);</span></span></code></pre></div><p><strong>使用定时器实现节流</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeout;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">timeout) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }, wait);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用示例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handleScroll</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;滚动事件&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;scroll&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handleScroll);</span></span></code></pre></div><h3 id="总结-3" tabindex="-1">总结 <a class="header-anchor" href="#总结-3" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><strong>防抖（Debounce）</strong>：在事件停止触发后的一段时间内执行函数，适用于减少频繁事件触发后只需执行一次的场景。</li><li><strong>节流（Throttle）</strong>：在一定时间间隔内只执行一次函数，适用于限制函数执行频率的场景。</li></ul><p>这两种技术都可以有效地提高应用性能，减少不必要的计算和资源消耗。</p><h4 id="防抖" tabindex="-1">防抖 <a class="header-anchor" href="#防抖" aria-label="Permalink to &quot;防抖&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> debounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args), delay);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="节流" tabindex="-1">节流 <a class="header-anchor" href="#节流" aria-label="Permalink to &quot;节流&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> throttle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">limit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastFunc;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastRan;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lastRan) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      lastRan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lastFunc);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      lastFunc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastRan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> limit) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          func.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          lastRan </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }, limit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastRan));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="三级联动下拉菜单" tabindex="-1">三级联动下拉菜单 <a class="header-anchor" href="#三级联动下拉菜单" aria-label="Permalink to &quot;三级联动下拉菜单&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">select</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;province&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">select</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;city&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">select</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;district&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Province1: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    City1: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;District1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;District2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    City2: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;District3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;District4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Province2: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    City3: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;District5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;District6&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    City4: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;District7&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;District8&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> populateSelect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  select.innerHTML </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  options.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">option</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> opt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;option&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    opt.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> opt.textContent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> option;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    select.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(opt);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> provinceSelect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;province&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> citySelect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;city&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> districtSelect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;district&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">populateSelect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(provinceSelect, Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">provinceSelect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;change&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cities</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data[provinceSelect.value]);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  populateSelect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(citySelect, cities);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  populateSelect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(districtSelect, data[provinceSelect.value][cities[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">citySelect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;change&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  populateSelect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(districtSelect, data[provinceSelect.value][citySelect.value]);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="_65-事件委托" tabindex="-1">65. 事件委托 <a class="header-anchor" href="#_65-事件委托" aria-label="Permalink to &quot;65. 事件委托&quot;">​</a></h2><p>事件委托是一种将事件处理器绑定到父元素而不是每个子元素的技术。通过利用<strong>事件冒泡，父元素可以处理其子元素的事件</strong>。这样可以减少事件处理器的数量，提高性能。</p><h3 id="示例-6" tabindex="-1">示例 <a class="header-anchor" href="#示例-6" aria-label="Permalink to &quot;示例&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;list&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Item 1&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Item 2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Item 3&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;list&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (event.target.tagName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;LI&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Clicked item:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.target.textContent);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="_66-echarts-和地图" tabindex="-1">66. ECharts 和地图 <a class="header-anchor" href="#_66-echarts-和地图" aria-label="Permalink to &quot;66. ECharts 和地图&quot;">​</a></h2><p>ECharts 是一个用于可视化数据的开源 JavaScript 图表库。它提供了丰富的图表类型和强大的定制功能，可以用于创建各种数据可视化图表，包括地图。</p><h3 id="示例-7" tabindex="-1">示例 <a class="header-anchor" href="#示例-7" aria-label="Permalink to &quot;示例&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width: 600px;height:400px;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chart </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> echarts.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> option </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    title: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      text: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ECharts 示例&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tooltip: {},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    xAxis: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      data: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;衬衫&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;羊毛衫&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;雪纺衫&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;裤子&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;高跟鞋&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;袜子&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    yAxis: {},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    series: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;销量&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        data: [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  chart.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setOption</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(option);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="地图示例" tabindex="-1">地图示例 <a class="header-anchor" href="#地图示例" aria-label="Permalink to &quot;地图示例&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;map&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width: 600px;height:400px;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://cdn.jsdelivr.net/npm/echarts/map/js/china.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chart </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> echarts.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;map&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> option </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    title: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      text: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;中国地图&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    tooltip: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      trigger: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    visualMap: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      min: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      max: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      left: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;left&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      top: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bottom&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      text: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;高&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;低&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      inRange: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        color: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#e0ffff&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#006edd&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      calculable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    series: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;数据名称&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;map&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        mapType: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;china&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        roam: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        label: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          show: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        data: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;北京&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, value: Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">round</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">random</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;天津&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, value: Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">round</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">random</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 其他省市数据...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  chart.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setOption</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(option);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>通过这些示例，你可以了解如何使用 ECharts 创建图表和地图，并根据需要进行定制。</p><h2 id="_67-javascript-代码的运行顺序是什么" tabindex="-1">67. JavaScript 代码的运行顺序是什么 <a class="header-anchor" href="#_67-javascript-代码的运行顺序是什么" aria-label="Permalink to &quot;67. JavaScript 代码的运行顺序是什么&quot;">​</a></h2><p>JavaScript 代码的运行顺序是由事件循环（Event Loop）机制决定的。JavaScript 是一门单线程语言，但通过事件循环机制，可以处理异步操作，如定时器、网络请求、事件处理等，使程序能够在非阻塞的情况下执行。</p><p>以下是 JavaScript 代码运行的一般顺序：</p><ol><li><strong>同步代码执行</strong>： JavaScript 会按照代码的顺序依次执行同步任务，这些任务会形成一个执行栈。</li><li><strong>异步任务注册</strong>： 当遇到异步任务时，会将这些任务注册到相应的异步任务队列中，比如定时器队列、事件队列。</li><li><strong>事件循环</strong>： 当执行栈中的同步任务执行完毕，事件循环会从异步任务队列中取出任务并放入执行栈中执行。</li><li><strong>回调函数执行</strong>： 异步任务执行时，如果有回调函数，会将回调函数放入执行栈中执行。</li><li><strong>重复循环</strong>： 事件循环会不断重复上述过程，不断从异步任务队列中取出任务并执行，直至所有任务都执行完毕。</li></ol><p>需要注意的是，JavaScript 中的异步操作不会阻塞主线程，因此可以在异步任务执行的同时继续执行其他任务。这种机制使得 JavaScript 可以处理复杂的异步操作，同时保持响应性和性能。</p><p>总结起来，JavaScript 代码的运行顺序是先执行同步代码，然后根据事件循环机制执行异步任务。这个过程保证了 JavaScript 在单线程下能够有效地处理各种类型的任务。</p><h2 id="_68-对-node-js-有了解吗" tabindex="-1">68. 对 Node.js 有了解吗 <a class="header-anchor" href="#_68-对-node-js-有了解吗" aria-label="Permalink to &quot;68. 对 Node.js 有了解吗&quot;">​</a></h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，用于构建高性能的网络应用程序。它允许开发人员使用 JavaScript 编写服务器端代码，从而使 JavaScript 不仅限于浏览器环境，还可以用于构建服务器端应用。</p><p>以下是一些关键特点和用途：</p><ul><li><strong>非阻塞 I/O</strong>： 不会因为 I/O 操作而阻塞主线程，从而提高了应用程序的性能和响应能力。</li><li><strong>事件驱动</strong>： 基于事件驱动的编程模型，通过事件循环机制处理请求和响应。</li><li><strong>单线程</strong>： 尽管是单线程的，但通过异步和事件循环，它能够支持高并发和大规模的应用。</li><li><strong>模块化</strong>： 采用了 CommonJS 模块系统，可以将代码分割成小模块，提高了代码的可维护性和复用性。</li><li><strong>npm</strong>： 自带了一个强大的包管理工具 npm，用于安装、管理和发布代码包，可以轻松地使用第三方库。</li><li><strong>实时应用</strong>： 由于其非阻塞和事件驱动的特性，特别适用于开发实时应用，如聊天应用、游戏服务器、实时通知等。</li><li><strong>构建 Web 服务器</strong>： 可以用于构建高性能的 Web 服务器，处理 HTTP 请求和响应，从而构建灵活和可扩展的后端服务。</li><li><strong>构建命令行工具</strong>： Node.js 也可以用于开发命令行工具，从而方便地进行各种任务，如文件处理、自动化任务等。</li></ul><p>需要注意的是，Node.js 并不适合所有类型的应用，特别是在需要大量计算的情况下，因为它是单线程的。在这些情况下，可能需要考虑使用其他的技术栈。</p><h2 id="_69-javascript-如何做性能优化" tabindex="-1">69. JavaScript 如何做性能优化 <a class="header-anchor" href="#_69-javascript-如何做性能优化" aria-label="Permalink to &quot;69. JavaScript 如何做性能优化&quot;">​</a></h2><p>JavaScript 性能优化是开发过程中的一个关键方面，它可以提高网站或应用的加载速度、响应性能和用户体验。以下是一些常见的 JavaScript 性能优化技巧：</p><ul><li><strong>减少 HTTP 请求</strong></li><li><strong>压缩文件</strong></li><li><strong>延迟加载</strong></li><li><strong>缓存策略</strong></li><li><strong>使用 CDN</strong></li><li><strong>异步加载</strong></li><li><strong>DOM 操作优化</strong></li><li><strong>事件委托</strong></li><li><strong>减少重绘和回流</strong>： 避免频繁的修改样式属性，可以通过添加一个类名来一次性修改多个样式，减少重绘和回流。</li><li><strong>使用 Web Workers</strong>： 使用 Web Workers 在后台执行一些计算密集型任务，避免阻塞主线程。</li><li><strong>内存管理</strong>： 及时释放不再使用的对象和资源，避免内存泄漏，优化内存占用。</li><li><strong>代码分割</strong>： 使用模块化的代码结构，根据页面需要进行代码分割，只加载所需的模块。</li><li><strong>性能监测和分析</strong>： 使用浏览器开发者工具、性能分析工具（如 Lighthouse、WebPageTest）来检测和分析性能问题，定位瓶颈。</li><li><strong>移动端优化</strong>： 针对移动设备，使用响应式设计、适合移动端的图像格式（如 WebP），减少移动数据使用等。</li></ul><h2 id="_70-script-标签上的-defer-和-async" tabindex="-1">70. <code>script</code> 标签上的 <code>defer</code> 和 <code>async</code> <a class="header-anchor" href="#_70-script-标签上的-defer-和-async" aria-label="Permalink to &quot;70. \`script\` 标签上的 \`defer\` 和 \`async\`&quot;">​</a></h2><p>当使用 <code>&lt;script&gt;</code> 标签加载外部 JavaScript 文件时，<code>defer</code> 和 <code>async</code> 是两个常用的属性，用于控制脚本的加载和执行方式。它们都可以帮助优化页面加载性能，但它们的行为和效果有所不同。</p><h3 id="defer-属性" tabindex="-1"><code>defer</code> 属性 <a class="header-anchor" href="#defer-属性" aria-label="Permalink to &quot;\`defer\` 属性&quot;">​</a></h3><ul><li><code>defer</code> 属性用于异步加载脚本，但它保证脚本会按照它们在页面中出现的顺序执行。</li><li>多个带有 <code>defer</code> 属性的脚本会按照它们在页面上出现的顺序依次加载和执行。</li><li>脚本的加载不会阻塞 HTML 解析，页面内容会在脚本加载完成前呈现。</li><li>适合将脚本放在页面底部，因为它们会在文档解析完毕后执行。</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script1.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script2.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="async-属性" tabindex="-1"><code>async</code> 属性 <a class="header-anchor" href="#async-属性" aria-label="Permalink to &quot;\`async\` 属性&quot;">​</a></h3><ul><li><code>async</code> 属性也用于异步加载脚本，但它在加载完成后立即执行，不会阻塞后续内容的加载和渲染。</li><li>多个带有 <code>async</code> 属性的脚本的执行顺序无法保证，因此适合不依赖顺序的脚本。</li><li><code>async</code> 脚本的执行时机是在加载完成后立即执行，可能会在 <code>DOMContentLoaded</code> 事件之前或之后执行。</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script1.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script2.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>根据需求，你可以选择使用 <code>defer</code> 或 <code>async</code> 属性来控制脚本的加载和执行方式。如果脚本之间存在依赖关系并需要按顺序执行，使用 <code>defer</code>。如果脚本之间没有依赖关系，且你希望尽早加载并执行脚本，可以使用 <code>async</code>。注意，在使用 <code>async</code> 时，脚本可能会在页面的不同阶段执行，需要确保脚本之间的互相独立性。</p><h2 id="_71-websocket-实时通讯" tabindex="-1">71. WebSocket 实时通讯 <a class="header-anchor" href="#_71-websocket-实时通讯" aria-label="Permalink to &quot;71. WebSocket 实时通讯&quot;">​</a></h2><p>WebSocket 实时通讯可以用于聊天、客服、股票图、抢票、秒杀等应用场景。以下是一个简单的实现示例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 服务器端</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> io</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;socket.io&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;connection&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">socket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a user connected&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sendmsg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    io.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sendmsg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, msg);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 客户端</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> socket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> io</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://localhost:3000&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sendmsg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">msg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Message received:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, msg);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sendmsg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="_72-three-js-怎么实现的-3d" tabindex="-1">72. Three.js 怎么实现的（3D） <a class="header-anchor" href="#_72-three-js-怎么实现的-3d" aria-label="Permalink to &quot;72. Three.js 怎么实现的（3D）&quot;">​</a></h2><p>Three.js 是一个基于 WebGL 的 JavaScript 库，用于创建和展示 3D 图形。它封装了 WebGL 的底层 API，使得开发者可以更方便地创建复杂的 3D 场景、模型和动画。</p><p>你可以访问 <a href="http://www.webgl3d.cn/" target="_blank" rel="noreferrer">Three.js 官方网站</a> 获取更多信息和示例代码。</p><h2 id="_73-同时发起多个请求-worker" tabindex="-1">73. 同时发起多个请求（Worker） <a class="header-anchor" href="#_73-同时发起多个请求-worker" aria-label="Permalink to &quot;73. 同时发起多个请求（Worker）&quot;">​</a></h2><p>在前端开发中，有多种方式可以同时发起多个请求，以提高页面加载速度和用户体验。以下是一些常用的方法：</p><ul><li><strong>使用并行请求</strong>： 在浏览器中，可以同时发起多个 HTTP 请求来获取不同资源，如样式表、脚本文件、图像等。浏览器会自动并行处理这些请求，加快页面加载速度。</li><li><strong>使用多线程和 Web Workers</strong>： 在支持的情况下，可以使用 Web Workers 来在后台线程中并行处理一些耗时的任务，如数据处理、计算等，从而不阻塞主线程的执行。</li><li><strong>使用并发请求库</strong>： 一些请求库（如 Axios、Fetch）允许同时发起多个请求，可以使用 <code>Promise.all</code> 或其他并发操作来处理多个请求的结果。</li><li><strong>使用批量请求</strong>： 如果有多个小请求，可以将它们合并成一个批量请求，从而减少网络请求的次数。</li><li><strong>使用字体预加载</strong>： 如果网页中使用了自定义字体，可以通过预加载字体资源，以确保字体在页面加载时可用。</li><li><strong>使用图像预加载</strong>： 在需要加载大量图像的情况下，可以通过预加载图像资源，从而减少图像加载时的延迟。</li><li><strong>使用资源缓存</strong>： 在多个页面中重复使用的资源（如 logo、图标）可以进行缓存，减少重复下载的次数。</li><li><strong>使用 CDN</strong>： 使用内容分发网络（CDN）可以将资源分布到多个服务器，从而提高资源加载速度。</li></ul><p>需要根据具体的应用场景和需求来选择合适的方法来同时发起多个请求。同时，需要注意不要过度并行，以避免过多的网络连接和资源竞争，从而导致性能下降。</p><h2 id="_74-解决跨域的方式有哪些" tabindex="-1">74. 解决跨域的方式有哪些 <a class="header-anchor" href="#_74-解决跨域的方式有哪些" aria-label="Permalink to &quot;74. 解决跨域的方式有哪些&quot;">​</a></h2><p>解决跨域问题的方法有多种，以下是一些常见的方法：</p><ol><li>⭕<strong>配置代理 proxy</strong></li><li><strong>⭕CORS（跨域资源共享）</strong>： 服务器配置相应头</li><li>JSONP： 适用于简单的 GET 请求（很老的方法，现在不用了）</li><li><strong>⭕WebSocket</strong></li><li>document.domain + iframe</li><li><strong>⭕Nginx 反向代理</strong></li></ol><h2 id="_75-回调地狱-promise-async-await" tabindex="-1">75. 回调地狱（promise+async/await） <a class="header-anchor" href="#_75-回调地狱-promise-async-await" aria-label="Permalink to &quot;75. 回调地狱（promise+async/await）&quot;">​</a></h2><p>回调地狱，也称为嵌套回调，是指在异步编程中，多个嵌套的回调函数形成的一种深层次、难以阅读和维护的代码结构。这种情况通常发生在需要依次处理多个异步操作的场景，导致代码缩进层次增多，可读性差，调试和维护困难。</p><h3 id="回调地狱的示例代码" tabindex="-1">回调地狱的示例代码 <a class="header-anchor" href="#回调地狱的示例代码" aria-label="Permalink to &quot;回调地狱的示例代码&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asyncOperation1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  asyncOperation2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result1, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    asyncOperation3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result2, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">result3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 更多嵌套的回调</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="回调地狱的问题" tabindex="-1">回调地狱的问题 <a class="header-anchor" href="#回调地狱的问题" aria-label="Permalink to &quot;回调地狱的问题&quot;">​</a></h3><ul><li><strong>可读性差</strong>： 深层次的嵌套使代码难以阅读和理解，不易维护。</li><li><strong>错误处理困难</strong>： 错误处理需要在多个回调中处理，增加了代码的复杂性。</li><li><strong>可扩展性差</strong>： 当需要添加新的异步操作时，会进一步增加嵌套，使代码变得更加复杂。</li></ul><h3 id="避免回调地狱的方法" tabindex="-1">避免回调地狱的方法 <a class="header-anchor" href="#避免回调地狱的方法" aria-label="Permalink to &quot;避免回调地狱的方法&quot;">​</a></h3><ul><li><strong>使用 Promise</strong>： 使用 Promise 可以改善回调地狱问题，将异步操作链式调用，增加可读性和可维护性。</li><li><strong>使用 async/await</strong>： 使用 async/await 可以编写更清晰的异步代码，类似同步代码的写法，避免嵌套。</li><li><strong>拆分函数</strong>： 将多个嵌套的回调拆分为独立的函数，每个函数只处理一个异步操作，提高代码的可读性。</li><li><strong>使用库或工具</strong>： 一些异步库（如 async.js）或工具（如 Generators）可以帮助处理异步操作，减少嵌套。</li></ul><h2 id="_76-如何隐藏页面上的手机号" tabindex="-1">76. 如何隐藏页面上的手机号 <a class="header-anchor" href="#_76-如何隐藏页面上的手机号" aria-label="Permalink to &quot;76. 如何隐藏页面上的手机号&quot;">​</a></h2><p>隐藏手机号的方法有多种，以下是一些常见的方法：</p><ul><li><strong>字符替换</strong>： 将手机号的部分数字用星号或其他字符替换，以隐藏真实号码。例如：186****1234。</li><li><strong>使用加密</strong>： 对手机号进行加密，只在需要的时候解密显示，以保护手机号的真实值。</li><li><strong>前端控制</strong>： 通过字符替换或加密算法来隐藏手机号，但要注意，前端隐藏方法仍然可以被熟练的用户绕过。</li><li><strong>后端控制</strong>： 在服务器端进行手机号的字符替换或加密，确保不会将真实手机号传输到前端。</li><li><strong>使用图片</strong>： 将手机号渲染为图片，以图片形式显示，避免直接暴露文本内容。</li><li><strong>仅显示部分号码</strong>： 只显示手机号的部分前缀或后缀，以减少敏感信息的暴露。</li><li><strong>权限控制</strong>： 根据用户权限，只有在必要的情况下才显示完整的手机号。</li><li><strong>模糊显示</strong>： 使用模糊效果使手机号显示不清晰，但足够用户识别。</li></ul><h2 id="_77-登录页面的实现原理-其中-token-存在哪" tabindex="-1">77. 登录页面的实现原理，其中 Token 存在哪 <a class="header-anchor" href="#_77-登录页面的实现原理-其中-token-存在哪" aria-label="Permalink to &quot;77. 登录页面的实现原理，其中 Token 存在哪&quot;">​</a></h2><p>登录页面的实现原理通常涉及用户身份验证和会话管理。以下是一个常见的登录页面实现原理：</p><ol><li><strong>用户输入信息</strong>： 用户在登录页面输入用户名和密码。</li><li><strong>提交表单</strong>： 用户点击登录按钮，将用户名和密码发送到服务器端。</li><li><strong>服务器验证</strong>： 服务器端接收用户提交的信息后，会进行验证。验证包括检查用户名和密码是否匹配数据库中的记录。</li><li><strong>生成令牌（Token）</strong>： 如果用户信息验证成功，服务器会生成一个令牌，表示用户已经登录。令牌通常包含一些用户标识信息以及一些加密数据，用于在后续请求中验证用户身份。</li><li><strong>返回令牌</strong>： 服务器将生成的令牌作为响应返回给客户端（浏览器）。</li><li><strong>客户端存储令牌</strong>： 客户端通常会将令牌存储在浏览器的 Cookie 或本地存储中，以便在后续的请求中发送给服务器。</li><li><strong>令牌验证</strong>： 当用户在登录后访问其他受保护的页面时，浏览器会自动在请求头中附带令牌。服务器端会验证令牌的有效性，以确认用户身份。</li><li><strong>会话管理</strong>： 服务器端可以维护会话状态，以跟踪用户的登录状态和其他会话信息。会话可以保存在服务器端的内存、数据库或其他存储中。</li></ol><p>关于令牌（Token）的存储，有几种常见的方式：</p><ol><li><strong>HttpOnly Cookie</strong>： 令牌可以存储在 HttpOnly Cookie 中，这样可以防止客户端的 JavaScript 访问，提高安全性。</li><li><strong>LocalStorage 或 SessionStorage</strong>： 令牌也可以存储在浏览器的 LocalStorage 或 SessionStorage 中。</li><li><strong>传统 Cookie</strong>： 令牌也可以存储在传统的 Cookie 中，但与 HttpOnly Cookie 相比，可能存在一些安全风险。</li></ol><h2 id="_78-什么是同步异步-如何解决异步" tabindex="-1">78. 什么是同步异步，如何解决异步 <a class="header-anchor" href="#_78-什么是同步异步-如何解决异步" aria-label="Permalink to &quot;78. 什么是同步异步，如何解决异步&quot;">​</a></h2><p>同步和异步是编程中的两种不同的操作模式，用于描述代码执行的顺序和方式。</p><p><strong>同步</strong>： 在同步操作中，代码按照顺序依次执行，每个操作都会等待前一个操作完成后才会执行。当一个操作阻塞（如网络请求、文件读取）时，整个程序可能会被阻塞，直到操作完成。</p><p><strong>异步</strong>： 在异步操作中，代码不会按照顺序依次执行，而是通过回调函数、Promise、async/await 等机制来处理。异步操作允许程序在等待某个操作的同时，继续执行其他操作，提高了程序的响应性能。</p><p>解决异步操作的常见方法包括：</p><ul><li><p><strong>回调函数</strong>： 在异步操作完成后,执行传递给异步函数的回调函数,这是传统的解决异步的方式,但容易导致回调地狱和代码不易维护。</p></li><li><p><strong>Promise</strong>： Promise 是一种更优雅的处理异步的方式，它表示一个异步操作的最终完成或失败，并可以链式调用 <code>.then()</code> 和 <code>.catch()</code> 来处理结果或错误。</p></li><li><p><strong>async/await</strong>： async/await 是 ES6 引入的语法，使异步代码看起来更像同步代码，async 函数返回一个 Promise，而在 async 函数内部使用 <code>await</code> 来等待异步操作完成。</p></li><li><p><strong>事件监听</strong>： 使用事件监听机制，通过注册事件处理函数来处理异步操作的结果。</p></li><li><p><strong>定时器</strong>： 使用定时器函数如 <code>setTimeout</code> 或 <code>setInterval</code>，在一定时间后执行指定的代码。</p></li></ul><h2 id="_79-请求数据一般是在哪里处理的" tabindex="-1">79. 请求数据一般是在哪里处理的 <a class="header-anchor" href="#_79-请求数据一般是在哪里处理的" aria-label="Permalink to &quot;79. 请求数据一般是在哪里处理的&quot;">​</a></h2><p>在 Web 开发中，数据请求通常在前端和后端两个环节中进行处理：</p><p><strong>前端处理数据请求的主要任务包括</strong>：</p><ul><li>创建 <code>XMLHttpRequest</code> 对象或使用 <code>Fetch API</code> 发起异步请求。</li><li>处理响应数据，可以使用回调函数、Promise、async/await 等方式来处理异步操作结果。</li><li>更新页面内容，将获取的数据渲染到用户界面中。</li></ul><p>前端数据请求通常用于获取页面所需的数据，例如渲染动态内容、与用户交互等。前端也可能涉及到缓存、本地存储和一些简单的数据处理。</p><p><strong>后端处理数据请求的主要任务包括</strong>：</p><ul><li>解析请求参数，包括查询参数、请求体中的数据等。</li><li>处理业务逻辑，可能涉及数据库查询、计算、权限验证等。</li><li>生成响应数据，将处理后的数据打包成响应，并发送给前端。</li></ul><p>后端数据请求通常用于提供数据接口、处理用户提交的表单、执行业务逻辑等。后端也可能涉及到数据持久化、安全性、性能优化等方面的处理。</p><h2 id="_80-垃圾回收机制" tabindex="-1">80. 垃圾回收机制 <a class="header-anchor" href="#_80-垃圾回收机制" aria-label="Permalink to &quot;80. 垃圾回收机制&quot;">​</a></h2><p>浏览器的 JavaScript 具有自动垃圾回收机制，垃圾收集器会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。</p><p><strong>标记清除</strong></p><p>JavaScript 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为&quot;进入环境&quot;。从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为&quot;离开环境&quot;。</p><p><strong>引用计数</strong></p><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1。当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。</p><p><strong>浏览器内存泄漏</strong></p><p>内存泄漏是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存。</p><ul><li><p><strong>循环引用</strong>：当两个或多个对象之间存在相互引用，并且没有被其他对象引用，就会发生循环引用，从而导致内存泄漏。这种情况可以通过在对象之间断开引用来避免。</p></li><li><p><strong>定时器未清除</strong>：在 JavaScript 中使用 <code>setInterval()</code> 或 <code>setTimeout()</code> 函数时，必须确保在不需要它们时清除这些定时器。</p></li><li><p><strong>全局变量未清除</strong>：在 JavaScript 中，如果定义了全局变量，它们将一直存在于内存中，直到页面关闭。如果不需要全局变量，请确保在使用后将其删除或赋值为 <code>null</code>。</p></li><li><p><strong>闭包未正确使用</strong>：在 JavaScript 中，闭包可以让函数访问其定义时的作用域，但如果未正确使用闭包，也可能导致内存泄漏。在使用闭包时，请确保只保留必要的引用，并在不需要时删除它们。</p></li><li><p><strong>事件未正确解绑</strong>：在 JavaScript 中，如果注册了事件监听器却没有正确解绑，就会导致内存泄漏。例如，当一个 DOM 元素被删除时，它仍然会保留对事件监听器的引用，如果没有解绑，事件监听器将无法被垃圾回收。</p></li><li><p><strong>使用了三方库或框架</strong>：在使用三方库或框架时，需要确保它们没有内存泄漏问题。如果使用了存在内存泄漏问题的库或框架，就会导致整个应用程序出现内存泄漏问题。</p></li></ul>`,589)],g=s(l,[["render",function(t,k,p,e,r,E){return a(),i("div",null,h)}]]);export{o as __pageData,g as default};
