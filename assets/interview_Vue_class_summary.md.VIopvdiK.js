import{_ as i,c as e,o as l,a4 as a}from"./chunks/framework.B2xMVIVo.js";const p=JSON.parse('{"title":"Vue 总结","description":"","frontmatter":{},"headers":[],"relativePath":"interview/Vue_class_summary.md","filePath":"interview/Vue_class_summary.md","lastUpdated":1719234304000}'),o={name:"interview/Vue_class_summary.md"},d=[a(`<h1 id="vue-总结" tabindex="-1">Vue 总结 <a class="header-anchor" href="#vue-总结" aria-label="Permalink to &quot;Vue 总结&quot;">​</a></h1><h2 id="_1-nexttick" tabindex="-1">1. nextTick <a class="header-anchor" href="#_1-nexttick" aria-label="Permalink to &quot;1. nextTick&quot;">​</a></h2><ul><li>会在真实 DOM 更新之后调用。</li></ul><h2 id="_2-虚拟-dom" tabindex="-1">2. 虚拟 DOM <a class="header-anchor" href="#_2-虚拟-dom" aria-label="Permalink to &quot;2. 虚拟 DOM&quot;">​</a></h2><p>原因：因为 Vue 采用的是虚拟 DOM，所谓的虚拟 DOM 其实就是一个 JS 对象。</p><ol><li>Vue 数据发生改变后，不会立即执行更新到真实 DOM，而是先更新虚拟 DOM。</li><li>当虚拟 DOM 发送改变后，会通过 DIFF 算法将改变后的内容更新到真实 DOM 中。</li></ol><h2 id="_3-diff" tabindex="-1">3. DIFF <a class="header-anchor" href="#_3-diff" aria-label="Permalink to &quot;3. DIFF&quot;">​</a></h2><ul><li>用来对比新老 DOM，找到发生改变的地方，只更新有变化的地方，提升性能。</li></ul><h2 id="_4-vue-响应式" tabindex="-1">4. Vue 响应式 <a class="header-anchor" href="#_4-vue-响应式" aria-label="Permalink to &quot;4. Vue 响应式&quot;">​</a></h2><ul><li>在 Vue 2 中，数据的响应式是通过 <code>Object.defineProperty()</code> 来实现的。</li><li>在 Vue 3 中，数据的响应式是通过 <code>Proxy</code> 来实现的。</li></ul><h2 id="_5-forceupdate" tabindex="-1">5. $forceUpdate <a class="header-anchor" href="#_5-forceupdate" aria-label="Permalink to &quot;5. $forceUpdate&quot;">​</a></h2><ul><li>该函数是用来强制重新渲染组件。</li></ul><h2 id="_6-data-必须是函数" tabindex="-1">6. data 必须是函数 <a class="header-anchor" href="#_6-data-必须是函数" aria-label="Permalink to &quot;6. data 必须是函数&quot;">​</a></h2><ul><li><code>data</code> 必须是一个函数，而且该函数还要 <code>return</code> 出一个对象，因为每个组件都需要有一个自己独立的作用域，防止页面组件之间数据相互污染。</li></ul><h2 id="_7-计算属性的特点" tabindex="-1">7. 计算属性的特点 <a class="header-anchor" href="#_7-计算属性的特点" aria-label="Permalink to &quot;7. 计算属性的特点&quot;">​</a></h2><ol><li>计算属性具备缓存功能。</li><li>计算属性一上来会立即执行一次（非惰性）。</li><li>如果计算属性中使用到多个属性，那么这些属性都会被监听到，只要有一个发生变化，那么该函数就会被重新执行，写在计算属性中的所有响应式数据都会被监听到。</li><li>计算属性中一定要有一个 <code>return</code>，因为我们要计算一个可以显示的结果。</li><li>计算属性是多个值影响一个值。</li><li>计算属性不支持异步。</li><li>计算属性可以配置可写的计算属性。</li></ol><h2 id="_8-侦听器的特点" tabindex="-1">8. 侦听器的特点 <a class="header-anchor" href="#_8-侦听器的特点" aria-label="Permalink to &quot;8. 侦听器的特点&quot;">​</a></h2><ol><li>惰性。</li><li>没有缓存。</li><li>一个值影响多个值。</li><li>支持异步。</li><li>不需要返回值。</li></ol><h2 id="_9-条件判断" tabindex="-1">9. 条件判断 <a class="header-anchor" href="#_9-条件判断" aria-label="Permalink to &quot;9. 条件判断&quot;">​</a></h2><h3 id="v-if" tabindex="-1">v-if <a class="header-anchor" href="#v-if" aria-label="Permalink to &quot;v-if&quot;">​</a></h3><ol><li>惰性，默认条件不成立的时候不会被添加（具有更佳的初始渲染）。</li><li>通过添加或者移除一个元素实现显示隐藏。</li><li>不频繁切换，初始渲染的时候可以使用。</li></ol><h3 id="v-show" tabindex="-1">v-show <a class="header-anchor" href="#v-show" aria-label="Permalink to &quot;v-show&quot;">​</a></h3><ol><li>非惰性，默认条件不成立也会被添加。</li><li>通过 CSS 样式控制显示隐藏。</li><li>频繁切换显示的时候使用 v-show 性能更优。</li></ol><h3 id="v-if-和-v-for" tabindex="-1">v-if 和 v-for <a class="header-anchor" href="#v-if-和-v-for" aria-label="Permalink to &quot;v-if 和 v-for&quot;">​</a></h3><ul><li>可以一块使用，但是不推荐一起使用，因为两个的优先级不同。 <ul><li>在 Vue 3 中，v-if 的优先级更高。</li><li>在 Vue 2 中，v-for 的优先级更高。</li></ul></li></ul><h3 id="切换消耗" tabindex="-1">切换消耗 <a class="header-anchor" href="#切换消耗" aria-label="Permalink to &quot;切换消耗&quot;">​</a></h3><ul><li>v-if 更高的切换消耗。</li><li>v-show 更高的初始消耗。</li></ul><h2 id="_10-列表渲染" tabindex="-1">10. 列表渲染 <a class="header-anchor" href="#_10-列表渲染" aria-label="Permalink to &quot;10. 列表渲染&quot;">​</a></h2><ul><li>v-for 使用的时候一定要加上一个 <code>key</code> 属性，而且该 <code>key</code> 属性还要是一个唯一的值。</li><li>因为 Vue 使用的是虚拟 DOM，当我们在前面或者中间添加一个内容的时候，会在虚拟 DOM 的签名添加该内容，但是渲染成真实 DOM 后，原来的标签位置不会发生变化，只会在最后位置添加一个新的元素，导致我们的内容和真实 DOM 位置出现混乱的情况，如果要解决这个问题，就要使用 v-for 循环的时候添加一个唯一的 <code>key</code> 值将虚拟 DOM 和真实 DOM 进行绑定关联。</li></ul><h2 id="_11-事件处理" tabindex="-1">11. 事件处理 <a class="header-anchor" href="#_11-事件处理" aria-label="Permalink to &quot;11. 事件处理&quot;">​</a></h2><ul><li><code>v-on</code> 简写 <code>@</code></li><li><code>.self</code> 指明事件只有自身被点击的时候才会被触发，不会受到子元素冒泡影响。</li><li><code>.capture</code> 触发内部事件的时候，先执行外部的事件方法，然后再执行内部。</li><li><code>.stop</code> 是一个修饰符，该修饰符是用来阻止冒泡用的。</li><li><code>.prevent</code> 该修饰符是用来阻止默认事件用的。</li><li><code>.once</code> 设置该事件只会被触发一次，相当于是一次性的事件监听。</li></ul><h2 id="_12-v-model-双向数据绑定" tabindex="-1">12. v-model 双向数据绑定 <a class="header-anchor" href="#_12-v-model-双向数据绑定" aria-label="Permalink to &quot;12. v-model 双向数据绑定&quot;">​</a></h2><ul><li><code>change</code>：当内容发生变化且失去焦点的时候会触发。</li><li><code>input</code>：内容一旦发生改变会立即执行。</li><li><code>v-model</code> 双向数据绑定。</li><li><code>v-model.lazy</code> 该修饰符可以将双向数据绑定默认的 <code>input</code> 事件改为 <code>change</code> 事件。</li><li><code>v-model.number</code> 该修饰符可以自动将用户输入的内容转换成 <code>number</code> 类型。</li><li><code>v-model.trim</code> 该修饰符可以去除内容两端的空格，中间无法去除。</li></ul><h2 id="_13-ref" tabindex="-1">13. ref <a class="header-anchor" href="#_13-ref" aria-label="Permalink to &quot;13. ref&quot;">​</a></h2><ul><li>Vue 不主张我们操作 DOM，尽可能减少 DOM 直接操作，那么这个时候 <code>ref</code> 就非常重要了。</li><li><code>ref</code> 可以直接用来标记获取 DOM 元素，也可以获取标记一个组件，代表的是一个组件的实例。</li><li><code>this.$refs</code></li></ul><h2 id="_14-组件注册" tabindex="-1">14. 组件注册 <a class="header-anchor" href="#_14-组件注册" aria-label="Permalink to &quot;14. 组件注册&quot;">​</a></h2><h3 id="局部注册" tabindex="-1">局部注册 <a class="header-anchor" href="#局部注册" aria-label="Permalink to &quot;局部注册&quot;">​</a></h3><ul><li>只能在当前组件中进行使用。 <ol><li>声明一个组件。</li><li>注册局部组件。</li><li>使用组件，可以用单标签，也可以使用双标签。</li></ol></li></ul><h3 id="全局注册" tabindex="-1">全局注册 <a class="header-anchor" href="#全局注册" aria-label="Permalink to &quot;全局注册&quot;">​</a></h3><ul><li>在任何组件中都可以使用。</li></ul><h2 id="_15-props-父传子" tabindex="-1">15. props 父传子 <a class="header-anchor" href="#_15-props-父传子" aria-label="Permalink to &quot;15. props 父传子&quot;">​</a></h2><ul><li><code>props: [&#39;mytitle&#39;, &#39;user&#39;, &#39;num&#39;, &#39;isshow&#39;, &#39;aB&#39;]</code></li><li>在父组件中使用子组件的时候，给其添加一些要传递的内容，内容通过属性进行传递。</li><li>在子组件中的 <code>props</code> 选项中进行接收即可使用。</li><li>属性的名称不能使用大写，可以使用连接符进行传递，但是接收的时候不能使用连接符的方式接收，我们需要使用小驼峰进行接收。</li></ul><h2 id="_16-单向数据流" tabindex="-1">16. 单向数据流 <a class="header-anchor" href="#_16-单向数据流" aria-label="Permalink to &quot;16. 单向数据流&quot;">​</a></h2><ul><li>Vue 中单向数据流，就是子组件中只能使用父组件传递过来的数据，但是不能进行数据的修改。</li><li>如果我们子组件非要改数据也是有方法的： <ol><li>在子组件中将父组件传递的数据复制一份，然后改自己的数据即可（父组件发生改变其不具备响应式）。</li><li>告诉父组件，让父组件自己去修改（子传父）。</li></ol></li></ul><h2 id="_17-组件传值属性验证" tabindex="-1">17. 组件传值属性验证 <a class="header-anchor" href="#_17-组件传值属性验证" aria-label="Permalink to &quot;17. 组件传值属性验证&quot;">​</a></h2><ol><li>定义类型的时候可以通过一个数组的形式定义多类型。</li><li>设置该属性为必填属性。</li><li>配置一个默认值，当父组件没有传递的时候会使用这里的默认值。</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 验证传递参数的数据类型为数字</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Number,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 定义类型的时候可以通过一个数组的形式定义多类型</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  sex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [String, Number, Boolean, Object, Array],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [String],</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置该属性为必填属性</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    required</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 配置一个默认值，当父组件没有传递的时候会使用这里的默认值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Number</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_18-自定义事件-子传父" tabindex="-1">18. 自定义事件，子传父 <a class="header-anchor" href="#_18-自定义事件-子传父" aria-label="Permalink to &quot;18. 自定义事件，子传父&quot;">​</a></h2><ol><li>在父组件中先定义接收子组件传递数据的方法。</li><li>使用组件的时候，监听自定义事件。</li><li>子组件在特定的时间特定的地方来触发自定义事件。</li></ol><ul><li><code>this.$emit</code> 是用来触发自定义事件用的。</li></ul><h2 id="_19-属性透传" tabindex="-1">19. 属性透传 <a class="header-anchor" href="#_19-属性透传" aria-label="Permalink to &quot;19. 属性透传&quot;">​</a></h2><ul><li>就是父组件在使用子组件的时候，给其添加 <code>class</code>、<code>style</code> 或 <code>v-on</code> 会被直接传递到该组件的根标签上进行使用。</li><li>组件的根节点最好只有一个，如果有多个根节点，父组件通过属性透传的属性就无法确定要添加在哪个根节点上。</li><li>我们可以通过设置 <code>v-bind=&#39;$attrs&#39;</code> 的方式指明添加到哪里。</li><li>被 <code>props</code> 所接收的属性，将无法被透传。</li><li>配置 <code>inheritAttrs: false</code> 该属性可以将属性透传关闭掉，属性不做继承。</li></ul><h2 id="_20-插槽" tabindex="-1">20. 插槽 <a class="header-anchor" href="#_20-插槽" aria-label="Permalink to &quot;20. 插槽&quot;">​</a></h2><h3 id="普通插槽" tabindex="-1">普通插槽 <a class="header-anchor" href="#普通插槽" aria-label="Permalink to &quot;普通插槽&quot;">​</a></h3><ul><li>插槽作用是内容分发，可以在组件内指定区域插入一些标签内容。</li><li><code>slot</code> 就是我们的插槽，插槽可以在使用组件的时候，向组件内添加一些独有的内容。插槽可以理解为内容分发。一个 <code>slot</code> 只能插入一段内容，如果我们给 <code>slot</code> 插入多个不同的内容，而且要显示在组件的不同位置，这时就出现一个问题，内容会被渲染多次。<code>slot</code> 可以看做是一个插槽的出口（占位符），组件内的子元素会被显示在这里。一个 <code>slot</code> 可以插入多个内容。我们应该做的是一个插槽插一个内容。</li></ul><h3 id="具名插槽" tabindex="-1">具名插槽 <a class="header-anchor" href="#具名插槽" aria-label="Permalink to &quot;具名插槽&quot;">​</a></h3><ul><li>在子组件中定义 <code>&lt;slot&gt;</code> 标签的时候，给其添加一个 <code>name</code> 属性。</li><li>在父组件中使用的时候加一个 <code>v-slot:插槽名称</code>。</li></ul><h3 id="作用域插槽" tabindex="-1">作用域插槽 <a class="header-anchor" href="#作用域插槽" aria-label="Permalink to &quot;作用域插槽&quot;">​</a></h3><ul><li>在子组件中定义 <code>&lt;slot&gt;</code> 标签的时候，可以给其添加一些属性，这些属性就是要传递到父组件模板中的数据。</li><li>在父组件中通过 <code>v-slot:插槽名称=&quot;接收的属性&quot;</code>。</li></ul><h2 id="_21-依赖注入" tabindex="-1">21. 依赖注入 <a class="header-anchor" href="#_21-依赖注入" aria-label="Permalink to &quot;21. 依赖注入&quot;">​</a></h2><ul><li>所谓的依赖注入，就是祖先组件给后代组件传值，不仅可以传递数据，也可以传递函数。</li><li><code>provide</code> 是用来提供依赖数据的，里面的数据会直接传递到后代组件中。</li><li><code>inject</code> 是后代组件用来接收祖先组件提供的数据，使用方法和 <code>props</code> 一样。</li></ul><h2 id="_22-自定义指令" tabindex="-1">22. 自定义指令 <a class="header-anchor" href="#_22-自定义指令" aria-label="Permalink to &quot;22. 自定义指令&quot;">​</a></h2><ul><li>自定义指令的选项是 <code>directives</code>。</li><li>自定义指令的时候不需要加 <code>v-</code>，在标签中使用的时候可以使用 <code>v-foc</code> 即可。</li></ul><h3 id="自定义指令的核心注意事项是在其生命周期上" tabindex="-1">自定义指令的核心注意事项是在其生命周期上 <a class="header-anchor" href="#自定义指令的核心注意事项是在其生命周期上" aria-label="Permalink to &quot;自定义指令的核心注意事项是在其生命周期上&quot;">​</a></h3><ul><li><code>mounted</code>：当指令加到标签中，渲染生效后触发。</li><li><code>updated</code>：当前指令中被添加的元素或者组件，指令的值发生变化时调用。</li></ul><h2 id="_23-指令" tabindex="-1">23. 指令 <a class="header-anchor" href="#_23-指令" aria-label="Permalink to &quot;23. 指令&quot;">​</a></h2><ul><li><code>v-html</code> 渲染内容时解析 HTML 和样式。</li><li><code>v-text</code> 渲染普通文本。</li><li><code>v-if</code> 条件判断显示隐藏。</li><li><code>v-show</code> 添加判断显示隐藏（通过 CSS 实现显示隐藏）。</li><li><code>v-for</code> 列表循环渲染。</li><li><code>v-bind</code> 绑定属性。</li><li><code>v-model</code> 双向数据绑定。</li><li><code>v-on</code> 事件监听。</li><li><code>v-slot</code> 具名插槽使用。</li><li><code>v-pre</code> 跳过该元素和所有子元素的编译。</li><li><code>v-once</code> 只渲染一次，后期更新不做处理。</li><li><code>v-memo</code> 做缓存，内部内容发生变化需要依赖改变后才会更新。</li><li><code>v-cloak</code> 将无法立即显示的内容先隐藏掉，当准备显示的时候直接显示即可。</li></ul><h2 id="_24-动态组件" tabindex="-1">24. 动态组件 <a class="header-anchor" href="#_24-动态组件" aria-label="Permalink to &quot;24. 动态组件&quot;">​</a></h2><ul><li><code>component</code> 组件添加 <code>is</code> 属性，来指明当前组件要显示什么组件，可以通过 <code>is</code> 来动态改变要显示的组件。</li><li>组件需要先执行注册代码。</li></ul><h2 id="_25-keep-alive-组件缓存" tabindex="-1">25. keep-alive 组件缓存 <a class="header-anchor" href="#_25-keep-alive-组件缓存" aria-label="Permalink to &quot;25. keep-alive 组件缓存&quot;">​</a></h2><ul><li><code>keep-alive</code> 缓存组件用的标签。</li><li>将要缓存的组件写在 <code>keep-alive</code> 中。</li><li><code>keep-alive</code> 中有三个属性： <ul><li><code>include</code>：包含的组件会被缓存。</li><li><code>exclude</code>：里面的内容不会被缓存。</li><li><code>max</code>：缓存组件的最大数量。</li></ul></li><li><code>include</code> 和 <code>exclude</code> 中需要的是组件的 <code>name</code>。</li></ul><h2 id="_26-transition-动画过渡" tabindex="-1">26. transition 动画过渡 <a class="header-anchor" href="#_26-transition-动画过渡" aria-label="Permalink to &quot;26. transition 动画过渡&quot;">​</a></h2><ul><li><code>transition</code> 标签是专门用来做动画过渡用的。</li><li><code>transition</code> 内部只能有一个根标签。</li><li><code>transition</code> 可以设置一个 <code>name</code> 属性，标记我们 <code>class</code> 用什么开头。</li><li>属性 <code>appear</code> 配置非惰性，运行立即执行一次动画。</li></ul><h3 id="多个根标签动画" tabindex="-1">多个根标签动画 <a class="header-anchor" href="#多个根标签动画" aria-label="Permalink to &quot;多个根标签动画&quot;">​</a></h3><ul><li>如果需要执行多个根标签动画，那么我们也可以使用动画组来实现 <code>transition-group</code>。</li></ul><h2 id="_27-teleport-传送" tabindex="-1">27. teleport 传送 <a class="header-anchor" href="#_27-teleport-传送" aria-label="Permalink to &quot;27. teleport 传送&quot;">​</a></h2><ul><li><code>teleport</code> 是用来做传送用的，<code>to</code> 属性是指定我们将内容传送到什么地方去，该属性可以是标签名称，也可以是一个 <code>id</code>，建议使用 <code>id</code>。这样才能确保传送位置的准确性。传送内容可以传送到任意位置。</li></ul><h2 id="_28-mixins-混入" tabindex="-1">28. mixins 混入 <a class="header-anchor" href="#_28-mixins-混入" aria-label="Permalink to &quot;28. mixins 混入&quot;">​</a></h2><ul><li><code>mixins</code> 是可以将公共的属性和方法业务逻辑放在一个混入中。</li><li>在需要使用的时候直接混入到组件实例中即可。</li><li>对应数据、函数、计算属性、侦听器，组件自身的优先级更高。</li><li>对应生命周期，混入的优先级更高。</li></ul>`,79)],k=i(o,[["render",function(s,t,r,c,n,h){return l(),e("div",null,d)}]]);export{p as __pageData,k as default};
