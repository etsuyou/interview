import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.B2xMVIVo.js";const g=JSON.parse('{"title":"Vue-Hangzhou 面试题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue-hangzhou.md","filePath":"interview/vue-hangzhou.md","lastUpdated":1719234304000}'),l={name:"interview/vue-hangzhou.md"},t=[n(`<h1 id="vue-hangzhou-面试题" tabindex="-1">Vue-Hangzhou 面试题 <a class="header-anchor" href="#vue-hangzhou-面试题" aria-label="Permalink to &quot;Vue-Hangzhou 面试题&quot;">​</a></h1><h2 id="_1-vuex-页面刷新数据丢失怎么解决" tabindex="-1">1. Vuex 页面刷新数据丢失怎么解决？ <a class="header-anchor" href="#_1-vuex-页面刷新数据丢失怎么解决" aria-label="Permalink to &quot;1. Vuex 页面刷新数据丢失怎么解决？&quot;">​</a></h2><p>在使用 Vue.js 和 Vuex 的应用中，页面刷新导致数据丢失通常是因为刷新后应用的状态被重置，而 Vuex 的状态是存储在内存中的。为了解决这个问题，可以考虑以下几种方法：</p><h3 id="持久化存储" tabindex="-1">持久化存储 <a class="header-anchor" href="#持久化存储" aria-label="Permalink to &quot;持久化存储&quot;">​</a></h3><p>使用本地存储（localStorage 或 sessionStorage）或者使用 Cookie 将 Vuex 的状态数据存储在浏览器中。这样，当用户刷新页面时，可以在应用初始化时从本地存储中恢复之前保存的状态。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在 Vuex 模块中实现本地存储</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> store</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vuex.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  state: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // your state properties</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mutations: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // your mutations</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  actions: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // your actions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 本地存储插件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    createPersistedState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>要使用本地存储插件，需要安装 <code>vuex-persistedstate</code>：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> vuex-persistedstate</span></span></code></pre></div><h3 id="服务端存储" tabindex="-1">服务端存储 <a class="header-anchor" href="#服务端存储" aria-label="Permalink to &quot;服务端存储&quot;">​</a></h3><p>将应用的状态存储在服务器端。这样，用户在刷新页面时可以通过请求服务器来获取最新的状态数据。</p><h3 id="路由参数" tabindex="-1">路由参数 <a class="header-anchor" href="#路由参数" aria-label="Permalink to &quot;路由参数&quot;">​</a></h3><p>如果数据可以通过 URL 参数传递，可以在路由中包含相关的参数，以便在刷新页面时重新加载数据。</p><h3 id="在页面卸载时保存状态" tabindex="-1">在页面卸载时保存状态 <a class="header-anchor" href="#在页面卸载时保存状态" aria-label="Permalink to &quot;在页面卸载时保存状态&quot;">​</a></h3><p>使用 <code>window.beforeunload</code> 事件监听器，在用户关闭或刷新页面之前保存 Vuex 的状态。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;beforeunload&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 保存状态到本地存储或服务器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>选择适合应用场景的方法取决于需求和安全性考虑。每种方法都有其优劣和适用场景，因此在实施之前，请根据具体情况选择最合适的方法。</p><h2 id="_2-谈谈-mvvm-和-mvc-的区别" tabindex="-1">2. 谈谈 MVVM 和 MVC 的区别 <a class="header-anchor" href="#_2-谈谈-mvvm-和-mvc-的区别" aria-label="Permalink to &quot;2. 谈谈 MVVM 和 MVC 的区别&quot;">​</a></h2><h3 id="mvc-model-view-controller" tabindex="-1">MVC（Model-View-Controller） <a class="header-anchor" href="#mvc-model-view-controller" aria-label="Permalink to &quot;MVC（Model-View-Controller）&quot;">​</a></h3><ol><li><strong>Model（模型）：</strong> 负责应用程序的数据和业务逻辑。</li><li><strong>View（视图）：</strong> 负责用户界面的展示，通常直接从模型中获取数据。</li><li><strong>Controller（控制器）：</strong> 处理用户输入，根据输入更新模型并更新视图。</li></ol><p>在 MVC 中，控制器充当模型和视图之间的中介者，负责处理用户输入并在必要时更新模型和视图。MVC 模式强调分离关注点，使得应用程序的不同部分可以独立开发和维护。</p><h3 id="mvvm-model-view-viewmodel" tabindex="-1">MVVM（Model-View-ViewModel） <a class="header-anchor" href="#mvvm-model-view-viewmodel" aria-label="Permalink to &quot;MVVM（Model-View-ViewModel）&quot;">​</a></h3><ol><li><strong>Model（模型）：</strong> 负责应用程序的数据和业务逻辑。</li><li><strong>View（视图）：</strong> 负责用户界面的展示。</li><li><strong>ViewModel（视图模型）：</strong> 将视图的状态和行为抽象成一个独立的对象，负责处理用户输入并更新模型和视图。ViewModel 通过数据绑定连接视图和模型。</li></ol><p>在 MVVM 中，视图模型起到了控制器的作用，但与传统的控制器不同的是，视图模型更加抽象和独立，通过数据绑定自动更新视图。这种自动化的数据绑定是 MVVM 的一个关键特点。</p><h3 id="区别总结" tabindex="-1">区别总结 <a class="header-anchor" href="#区别总结" aria-label="Permalink to &quot;区别总结&quot;">​</a></h3><ol><li><strong>数据绑定：</strong> MVVM 强调双向数据绑定，使得视图和视图模型之间的数据同步更加简单。MVC 通常是单向的，视图通过控制器从模型中获取数据。</li><li><strong>视图模型：</strong> MVVM 引入了视图模型，将视图的状态和行为抽象成一个独立的对象，简化了视图和模型之间的交互。MVC 中的控制器通常更加直接地处理用户输入和模型更新。</li><li><strong>关注点分离：</strong> MVC 强调关注点分离，但 MVVM 更进一步，通过数据绑定实现了视图和视图模型之间的解耦，使得代码更加模块化和可维护。</li></ol><p>选择使用哪种架构模式取决于项目的需求和开发团队的偏好，每种模式都有其适用的场景。在实际应用中，一些框架（如 Vue.js）采用了 MVVM 模式，而另一些框架（如 Angular）采用了 MVC 模式的变体。</p><h2 id="_3-虚拟-dom-是什么-有什么优缺点" tabindex="-1">3. 虚拟 DOM 是什么？有什么优缺点？ <a class="header-anchor" href="#_3-虚拟-dom-是什么-有什么优缺点" aria-label="Permalink to &quot;3. 虚拟 DOM 是什么？有什么优缺点？&quot;">​</a></h2><h3 id="虚拟-dom-的概念" tabindex="-1">虚拟 DOM 的概念 <a class="header-anchor" href="#虚拟-dom-的概念" aria-label="Permalink to &quot;虚拟 DOM 的概念&quot;">​</a></h3><p>虚拟 DOM（Virtual DOM）是前端框架（主要是 React 和 Vue）中一种用于提高性能的技术。它是一个虚拟的内存中的表示，类似于浏览器中的实际 DOM。通过在内存中维护一份虚拟 DOM 树，框架可以减少直接操作实际 DOM 的次数，从而提高应用的性能。</p><h3 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><ol><li><strong>初始化：</strong> 页面首次加载时，框架会通过 JavaScript 创建一个虚拟 DOM 树，该树结构与实际 DOM 结构相似。</li><li><strong>渲染：</strong> 当状态发生改变时，框架会生成一个新的虚拟 DOM 树。</li><li><strong>对比：</strong> 框架会将新的虚拟 DOM 树与之前的虚拟 DOM 树进行比较，找出两者之间的差异。</li><li><strong>更新：</strong> 框架只会将实际改变的部分更新到实际 DOM 中，而不是重新渲染整个页面。</li></ol><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ol><li><strong>性能提升：</strong> 通过减少直接操作实际 DOM 的次数，提高了页面渲染的效率，尤其在大型单页应用中。</li><li><strong>跨平台开发：</strong> 可以将虚拟 DOM 抽象为一个通用的接口，便于实现跨平台的开发，比如 React Native 和 Weex。</li><li><strong>简化开发：</strong> 框架通过比较虚拟 DOM 的差异，自动更新实际 DOM，开发者只需关注状态的变化，而不需要手动操作 DOM。</li></ol><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ol><li><strong>学习成本：</strong> 对于新手来说，理解虚拟 DOM 的概念可能需要一些时间。</li><li><strong>内存消耗：</strong> 虚拟 DOM 需要在内存中维护一份 DOM 树的副本，可能会导致一些额外的内存消耗。</li><li><strong>复杂性：</strong> 实现虚拟 DOM 的算法和机制可能相对复杂，对于一些小型项目而言，引入虚拟 DOM 可能显得过于繁琐。</li></ol><p>虚拟 DOM 的优缺点需要根据具体的应用场景和开发需求来考虑。在大型复杂的单页应用中，通常能够通过虚拟 DOM 带来的性能提升来补偿其引入的额外复杂性。而对于一些小型项目或者简单的页面，可能并不需要引入虚拟 DOM。</p><h2 id="_4-vue-router-有几种模式-这些模式的区别" tabindex="-1">4. Vue-router 有几种模式，这些模式的区别 <a class="header-anchor" href="#_4-vue-router-有几种模式-这些模式的区别" aria-label="Permalink to &quot;4. Vue-router 有几种模式，这些模式的区别&quot;">​</a></h2><h3 id="哈希模式-hash-mode" tabindex="-1">哈希模式（Hash mode） <a class="header-anchor" href="#哈希模式-hash-mode" aria-label="Permalink to &quot;哈希模式（Hash mode）&quot;">​</a></h3><ul><li><strong>模式配置：</strong> 在使用 Vue Router 时，默认的模式就是哈希模式。配置时，不需要额外的设置。</li><li><strong>URL 格式：</strong> 在哈希模式下，URL 中的路由路径会以 <code>#</code> 符号开始，例如 <code>http://example.com/#/user/123</code>。</li><li><strong>优点：</strong> 哈希模式不需要服务端配置，对于一些静态资源托管的场景非常方便，而且兼容性较好。</li></ul><h3 id="历史模式-history-mode" tabindex="-1">历史模式（History mode） <a class="header-anchor" href="#历史模式-history-mode" aria-label="Permalink to &quot;历史模式（History mode）&quot;">​</a></h3><ul><li><strong>模式配置：</strong> 若要使用历史模式，需要在创建 Vue Router 实例时进行配置。</li><li><strong>URL 格式：</strong> 在历史模式下，URL 中的路由路径是正常的路径，不再需要 <code>#</code> 符号，例如 <code>http://example.com/user/123</code>。</li><li><strong>优点：</strong> 历史模式的 URL 更加友好，看起来更像传统的 URL 结构，没有 <code>#</code> 符号。适用于需要更好用户体验的场景。</li><li><strong>注意：</strong> 使用历史模式时，需要服务器端进行配置以确保在直接访问 URL 时能够正确地返回对应的页面。否则，刷新页面或直接访问某个 URL 时可能会导致 404 错误。</li></ul><p>配置历史模式的 Vue Router 示例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;history&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 路由配置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>选择使用哈希模式还是历史模式取决于应用需求和服务器配置的情况。在大多数情况下，哈希模式是比较简便的选择，但如果需要更好的 URL 体验，并且能够正确处理刷新页面等操作，那么历史模式可能更适合。</p><h2 id="_5-路由-导航守卫种类和作用" tabindex="-1">5. 路由 - 导航守卫种类和作用 <a class="header-anchor" href="#_5-路由-导航守卫种类和作用" aria-label="Permalink to &quot;5. 路由 - 导航守卫种类和作用&quot;">​</a></h2><h3 id="全局导航守卫" tabindex="-1">全局导航守卫 <a class="header-anchor" href="#全局导航守卫" aria-label="Permalink to &quot;全局导航守卫&quot;">​</a></h3><p>全局导航守卫是在整个应用的生命周期中都能触发的导航守卫，包括：</p><ul><li><p><strong><code>beforeEach(to, from, next)</code>：</strong> 在路由切换开始时触发，常用于进行权限验证或全局状态的判断。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 进行一些权限判断或其他操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (to.meta.requiresAuth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">auth.isAuthenticated) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/login&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p><strong><code>afterEach(to, from)</code>：</strong> 在路由切换结束后触发，适用于执行一些页面切换后的操作，如埋点统计等。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">afterEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 埋点统计等操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ul><h3 id="路由独享守卫" tabindex="-1">路由独享守卫 <a class="header-anchor" href="#路由独享守卫" aria-label="Permalink to &quot;路由独享守卫&quot;">​</a></h3><p>路由独享守卫是在单个路由配置中定义的守卫，仅对特定的路由生效。包括：</p><ul><li><p><strong><code>beforeEnter(to, from, next)</code>：</strong> 在单个路由配置中定义，类似于 <code>beforeEach</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> route</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/example&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  component: ExampleComponent,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  beforeEnter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在进入路由之前执行一些操作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li></ul><h3 id="组件内的守卫" tabindex="-1">组件内的守卫 <a class="header-anchor" href="#组件内的守卫" aria-label="Permalink to &quot;组件内的守卫&quot;">​</a></h3><p>组件内的守卫是在组件内部定义的守卫，包括：</p><ul><li><p><strong><code>beforeRouteEnter(to, from, next)</code>：</strong> 在路由进入组件前调用，此时组件实例还未创建，可以通过回调函数访问组件实例。</p></li><li><p><strong><code>beforeRouteUpdate(to, from, next)</code>：</strong> 在当前路由改变，但是该组件被复用时调用，可以在该守卫中对路由参数的变化进行响应。</p></li><li><p><strong><code>beforeRouteLeave(to, from, next)</code>：</strong> 在导航离开该组件的对应路由时调用，可以在该守卫中进行离开前的确认操作。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  beforeRouteEnter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在进入路由前执行一些操作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 通过 \`vm\` 访问组件实例</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  beforeRouteUpdate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在路由参数变化时执行一些操作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  beforeRouteLeave</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在离开路由前执行一些确认操作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li></ul><p>通过使用这些导航守卫，可以更好地控制路由的切换过程，进行一些额外的逻辑处理，例如权限验证、数据加载、页面切换动画等。</p><h2 id="_6-路由-谈谈你对编程式导航的理解" tabindex="-1">6. 路由 - 谈谈你对编程式导航的理解 <a class="header-anchor" href="#_6-路由-谈谈你对编程式导航的理解" aria-label="Permalink to &quot;6. 路由 - 谈谈你对编程式导航的理解&quot;">​</a></h2><p>编程式导航是指通过编写代码来实现页面之间的切换和导航，而不是通过用户的交互行为（比如点击链接或按钮）来触发导航。在前端框架中，例如 Vue.js 和 React，提供了一些 API 来支持编程式导航。</p><h3 id="vue-router-中的编程式导航方法" tabindex="-1">Vue Router 中的编程式导航方法 <a class="header-anchor" href="#vue-router-中的编程式导航方法" aria-label="Permalink to &quot;Vue Router 中的编程式导航方法&quot;">​</a></h3><ol><li><p><strong><code>$router.push(location)</code>：</strong> 添加一个新的历史记录，导航到指定的路径。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 字符串路径</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/example&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对象形式，可以包含 path、query、params 等属性</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/example&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, query: { key: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } });</span></span></code></pre></div></li><li><p><strong><code>$router.replace(location)</code>：</strong> 替换当前历史记录，导航到指定的路径。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/example&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li><p><strong><code>$router.go(n)</code>：</strong> 在浏览器历史记录中前进或后退多少步。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 后退一步</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 前进一步</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ol><h3 id="为什么使用编程式导航" tabindex="-1">为什么使用编程式导航 <a class="header-anchor" href="#为什么使用编程式导航" aria-label="Permalink to &quot;为什么使用编程式导航&quot;">​</a></h3><ol><li><strong>在程序逻辑中控制导航：</strong> 通过编程式导航，可以在代码中根据一些条件或事件触发导航，而不必依赖于用户的交互行为。</li><li><strong>动态路由：</strong> 在某些场景下，可能需要根据程序运行时的状态动态地生成或修改路由，这时编程式导航会变得非常有用。</li><li><strong>处理导航时的逻辑：</strong> 有时候在导航时需要执行一些逻辑，比如进行数据加载、权限验证等，这些逻辑可以方便地与编程式导航结合使用。</li></ol><p>例子：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 编程式导航，根据条件跳转到不同的页面</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (condition) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/dashboard&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/login&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>总体来说，编程式导航为开发者提供了更大的灵活性和控制权，使得在应用中更容易实现一些复杂的导航逻辑。</p><h2 id="_7-计算属性和侦听器区别、使用场景" tabindex="-1">7. 计算属性和侦听器区别、使用场景 <a class="header-anchor" href="#_7-计算属性和侦听器区别、使用场景" aria-label="Permalink to &quot;7. 计算属性和侦听器区别、使用场景&quot;">​</a></h2><h3 id="计算属性-computed-properties" tabindex="-1">计算属性（Computed Properties） <a class="header-anchor" href="#计算属性-computed-properties" aria-label="Permalink to &quot;计算属性（Computed Properties）&quot;">​</a></h3><ol><li><p><strong>特点：</strong></p><ul><li>计算属性是基于响应式数据计算而来的，只有在相关依赖发生变化时才会重新计算。</li><li>计算属性是缓存的，只有依赖的数据发生改变时，下一次访问计算属性时才会重新计算，之后的访问直接返回缓存的结果。</li></ul></li><li><p><strong>使用场景：</strong></p><ul><li>当某个属性的值依赖于其他响应式数据时，使用计算属性。</li><li>在模板中使用计算属性，以简化模板中的表达式和逻辑。</li><li>对于一些消耗性能的计算，通过计算属性可以有效减少重复计算的次数。</li></ul></li></ol><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ fullName }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      firstName: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      lastName: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Doe&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  computed: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    fullName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`\${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">firstName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lastName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="侦听器-watchers" tabindex="-1">侦听器（Watchers） <a class="header-anchor" href="#侦听器-watchers" aria-label="Permalink to &quot;侦听器（Watchers）&quot;">​</a></h3><ol><li><p><strong>特点：</strong></p><ul><li>侦听器是在数据变化时执行异步或开销较大的操作时使用的。</li><li>侦听器可以监听数据的变化，执行自定义的逻辑。</li></ul></li><li><p><strong>使用场景：</strong></p><ul><li>当需要在数据变化时执行异步操作或较复杂的逻辑时，使用侦听器。</li><li>在监听一个对象时，可以深度监听对象的变化。</li></ul></li></ol><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ fullName }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      firstName: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      lastName: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Doe&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  computed: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    fullName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`\${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">firstName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lastName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  watch: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    firstName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`firstName changed from \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">oldVal</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} to \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newVal</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 在 firstName 变化时执行一些逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    lastName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`lastName changed from \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">oldVal</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} to \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newVal</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 在 lastName 变化时执行一些逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="如何选择" tabindex="-1">如何选择 <a class="header-anchor" href="#如何选择" aria-label="Permalink to &quot;如何选择&quot;">​</a></h3><ul><li>使用计算属性，当有一个需要基于其他数据计算得出的属性时。</li><li>使用侦听器，当需要在数据变化时执行异步或开销较大的操作时，或者需要深度监听对象的变化。</li></ul><p>总的来说，计算属性适合处理基于响应式数据的简单计算，而侦听器适合处理较为复杂的业务逻辑或异步操作。在实际开发中，可以根据具体的场景和需求选择使用计算属性或侦听器。</p><h2 id="_8-项目开发中有没有封装过组件-项目中封装了哪些组件" tabindex="-1">8. 项目开发中有没有封装过组件? 项目中封装了哪些组件 <a class="header-anchor" href="#_8-项目开发中有没有封装过组件-项目中封装了哪些组件" aria-label="Permalink to &quot;8. 项目开发中有没有封装过组件? 项目中封装了哪些组件&quot;">​</a></h2><p>以下是一些可能在项目中封装的常见组件：</p><h3 id="_1-通用组件" tabindex="-1">1. 通用组件 <a class="header-anchor" href="#_1-通用组件" aria-label="Permalink to &quot;1. 通用组件&quot;">​</a></h3><ul><li><strong>按钮组件：</strong> 封装不同样式和大小的按钮，以及点击事件处理。</li><li><strong>表单组件：</strong> 封装常用的表单元素，如输入框、下拉框、复选框等，以及表单验证逻辑。</li><li><strong>模态框组件：</strong> 封装弹窗、对话框等模态框组件。</li></ul><h3 id="_2-ui-库封装" tabindex="-1">2. UI 库封装 <a class="header-anchor" href="#_2-ui-库封装" aria-label="Permalink to &quot;2. UI 库封装&quot;">​</a></h3><ul><li>封装整个 UI 库，包括按钮、表单、弹窗、通知等，以提高整个项目的一致性和可维护性。</li></ul><h3 id="_3-数据展示组件" tabindex="-1">3. 数据展示组件 <a class="header-anchor" href="#_3-数据展示组件" aria-label="Permalink to &quot;3. 数据展示组件&quot;">​</a></h3><ul><li><strong>表格组件：</strong> 封装支持分页、排序、筛选等功能的表格组件。</li><li><strong>图表组件：</strong> 封装常见的图表，如折线图、柱状图等。</li><li><strong>轮播组件：</strong> 封装可配置的轮播图组件。</li></ul><h3 id="_4-导航组件" tabindex="-1">4. 导航组件 <a class="header-anchor" href="#_4-导航组件" aria-label="Permalink to &quot;4. 导航组件&quot;">​</a></h3><ul><li><strong>面包屑导航组件：</strong> 封装面包屑导航，用于显示用户的导航路径。</li><li><strong>侧边栏组件：</strong> 封装侧边栏导航，用于显示项目的主要导航链接。</li></ul><h3 id="_5-状态管理组件" tabindex="-1">5. 状态管理组件 <a class="header-anchor" href="#_5-状态管理组件" aria-label="Permalink to &quot;5. 状态管理组件&quot;">​</a></h3><ul><li><strong>加载状态组件：</strong> 封装页面或组件的加载状态，用于显示加载中、加载成功、加载失败等状态。</li><li><strong>空状态组件：</strong> 封装当页面或组件没有数据时的空状态提示。</li></ul><h3 id="_6-工具类组件" tabindex="-1">6. 工具类组件 <a class="header-anchor" href="#_6-工具类组件" aria-label="Permalink to &quot;6. 工具类组件&quot;">​</a></h3><ul><li><strong>日期选择器组件：</strong> 封装可配置的日期选择器。</li><li><strong>文件上传组件：</strong> 封装文件上传功能，包括拖拽上传、图片预览等。</li></ul><p>这些仅仅是一些常见的组件封装示例，实际项目中可能会有更多的定制组件。根据项目需求进行适当的组件封装，有助于提高代码的可维护性和重用性。</p><h2 id="_9-vue3-0-里为什么要用-proxy-api-替代-defineproperty-api" tabindex="-1">9. Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？ <a class="header-anchor" href="#_9-vue3-0-里为什么要用-proxy-api-替代-defineproperty-api" aria-label="Permalink to &quot;9. Vue3.0 里为什么要用 Proxy API 替代 defineProperty API？&quot;">​</a></h2><p>Vue 3.0 引入 Proxy API 替代 Object.defineProperty API 的一个主要原因是 Proxy 具有更强大和灵活的功能，以及对响应式系统的更好支持。以下是一些使用 Proxy 的优点：</p><ol><li><p><strong>更丰富的拦截操作：</strong> Proxy 提供了多达 13 种不同的拦截操作，可以覆盖对象的各个方面，包括读取、写入、删除属性等。而 Object.defineProperty 只能监听属性的读取和写入。</p></li><li><p><strong>数组变化的监听：</strong> 使用 Proxy，可以直接监听数组的变化，而无需像 Vue 2.x 中那样通过重写数组方法来实现。这样使得 Vue 3.0 在处理数组时更加高效和灵活。</p></li><li><p><strong>深层响应式：</strong> Proxy 使得深层对象的响应式变得更加容易实现，因为它可以递归地代理对象的每个嵌套属性。</p></li><li><p><strong>取消属性的可配置性：</strong> 在使用 Object.defineProperty 时，某些属性的可配置性（configurable）可能会受到限制，而 Proxy 则可以处理不可配置的属性。</p></li><li><p><strong>性能提升：</strong> 在一些场景下，Proxy 可以比 Object.defineProperty 更快，特别是在大型响应式数据的情况下。</p></li></ol><p>下面是一个简单的比较示例，演示了使用 Proxy 和 Object.defineProperty 监听属性的方式：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 Proxy</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`读取属性：\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target[key];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`设置属性：\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} = \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      target[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 Object.defineProperty</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj2, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;读取属性：name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`设置属性：name = \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Proxy 输出：设置属性：name = John</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Proxy 输出：读取属性：name</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj2.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Object.defineProperty 输出：设置属性：name = John</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj2.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Object.defineProperty 输出：读取属性：name</span></span></code></pre></div><p>综上所述，Vue 3.0 选择使用 Proxy API 而不是 Object.defineProperty 是为了提供更好的性能和更丰富的功能，使得 Vue 3.0 的响应式系统更加灵活和高效。</p><h2 id="_10-说一下-diff-算法" tabindex="-1">10. 说一下 Diff 算法 <a class="header-anchor" href="#_10-说一下-diff-算法" aria-label="Permalink to &quot;10. 说一下 Diff 算法&quot;">​</a></h2><p>Virtual DOM 的 diff 算法是在前端框架中用于高效更新视图的关键技术之一。在 Vue 和 React 等框架中，使用虚拟 DOM 来描述页面结构，通过 diff 算法比较新旧虚拟 DOM 的差异，最终只更新需要更新的部分，从而减少对实际 DOM 的操作，提高性能。</p><p>以下是 Virtual DOM 的 diff 算法的基本流程：</p><ol><li><p><strong>生成新旧虚拟 DOM 树：</strong> 在每次更新时，框架会生成新的虚拟 DOM 树和上一次渲染时的虚拟 DOM 树。</p></li><li><p><strong>开始比较：</strong> 从树的根节点开始逐层比较，找到两棵树的不同之处。</p></li><li><p><strong>深度优先遍历：</strong> 对树进行深度优先遍历，比较同一层级的节点。</p></li><li><p><strong>节点比较：</strong> 比较相同层级的节点，分为四种情况：</p><ul><li>如果节点类型不同，直接替换节点。</li><li>如果节点类型相同，但是内容不同，更新节点内容。</li><li>如果节点类型相同，但是属性不同，更新节点属性。</li><li>如果节点类型相同，但是有子节点，递归比较子节点。</li></ul></li><li><p><strong>处理列表：</strong> 针对列表节点，采用一些特殊的策略，如 key 的使用，来提高比较效率。</p></li><li><p><strong>生成差异对象：</strong> 在比较的过程中，生成一个差异对象，记录需要进行的操作，包括插入、删除、更新等。</p></li><li><p><strong>批量更新：</strong> 将差异对象应用到实际的 DOM 树上，完成一次更新。</p></li></ol><p>通过这样的 diff 算法，前端框架能够在更新视图时最小化对实际 DOM 的操作，提高性能和用户体验。需要注意的是，虽然 diff 算法可以有效减少更新的开销，但也并非是万能的，特别是在一些复杂的场景下，仍然需要开发者注意性能优化。</p><h2 id="_11-谈谈你对-keep-alive-的理解-并说出应用场景" tabindex="-1">11. 谈谈你对 keep-alive 的理解，并说出应用场景 <a class="header-anchor" href="#_11-谈谈你对-keep-alive-的理解-并说出应用场景" aria-label="Permalink to &quot;11. 谈谈你对 keep-alive 的理解，并说出应用场景&quot;">​</a></h2><p><code>&lt;keep-alive&gt;</code> 是 Vue.js 提供的一个抽象组件，用于保留组件状态或避免多次渲染。它主要的作用是在组件切换时将组件缓存起来，而不是每次切换都重新创建和销毁组件，从而提高性能。</p><h3 id="主要特点和用法" tabindex="-1">主要特点和用法 <a class="header-anchor" href="#主要特点和用法" aria-label="Permalink to &quot;主要特点和用法&quot;">​</a></h3><ol><li><p><strong>缓存组件状态：</strong> <code>&lt;keep-alive&gt;</code> 包裹的组件在切换时不会被销毁，而是被缓存起来，保留了组件的状态，包括数据和状态。</p></li><li><p><strong>钩子函数：</strong> <code>&lt;keep-alive&gt;</code> 提供了两个生命周期钩子函数，分别是 <code>activated</code> 和 <code>deactivated</code>，用于在组件被激活和失活时执行相应的逻辑。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">component</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;currentComponent&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>include 和 exclude 属性：</strong> <code>&lt;keep-alive&gt;</code> 提供了 <code>include</code> 和 <code>exclude</code> 属性，允许你指定哪些组件需要被缓存或不需要被缓存。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :include</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[&#39;componentA&#39;, &#39;componentB&#39;]&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">router-view</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ol><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><ol><li><p><strong>缓存有状态的组件：</strong> 当某个组件包含有状态的数据，而这个组件在多次切换时不希望重新初始化和销毁，可以使用 <code>&lt;keep-alive&gt;</code> 进行缓存，提高性能。</p></li><li><p><strong>避免重复数据获取：</strong> 如果一个组件在每次激活时都会进行一些异步数据的获取，而这些数据在组件间是共享的，可以通过 <code>&lt;keep-alive&gt;</code> 避免多次触发数据请求。</p></li><li><p><strong>优化页面切换体验：</strong> 在一些需要频繁切换页面的场景，使用 <code>&lt;keep-alive&gt;</code> 可以保留上一个页面的状态，提高用户体验。</p></li><li><p><strong>复用组件实例：</strong> 当一个组件是可复用的，且每次使用时需要保持之前的状态时，可以考虑使用 <code>&lt;keep-alive&gt;</code> 进行缓存。</p></li></ol><p>需要注意的是，虽然 <code>&lt;keep-alive&gt;</code> 能够提高性能，但过度使用可能会导致内存占用增加，因此在使用时需要根据具体场景权衡性能和内存消耗。</p><h2 id="_12-spa-首屏加载慢如何解决" tabindex="-1">12. SPA 首屏加载慢如何解决 <a class="header-anchor" href="#_12-spa-首屏加载慢如何解决" aria-label="Permalink to &quot;12. SPA 首屏加载慢如何解决&quot;">​</a></h2><p>解决单页面应用（SPA）首屏加载慢的问题通常需要综合考虑多个因素，包括网络请求、资源优化、代码分割等。以下是一些常见的优化策略：</p><ol><li><p><strong>代码分割（Code Splitting）：</strong> 将整个应用划分成更小的模块，只在需要时才加载。可以使用工具如 Webpack 的动态导入（Dynamic Import）或 Vue Router 的懒加载来实现代码分割。这样可以减小首屏加载的体积，加快页面加载速度。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue Router 懒加载</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Home</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./views/Home.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li><li><p><strong>懒加载图片：</strong> 将页面中的图片懒加载，只有当图片出现在可视区域时再进行加载。这可以通过使用 <code>loading=&quot;lazy&quot;</code> 属性或引入第三方库实现。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">img</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;image.jpg&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loading</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;lazy&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> alt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Lazy-loaded Image&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div></li><li><p><strong>服务端渲染（SSR）：</strong> 对于需要搜索引擎优化（SEO）的 SPA，考虑使用服务端渲染。SSR 可以在服务器端生成首屏的 HTML，并将其直接返回给客户端，减少客户端的渲染时间。</p></li><li><p><strong>优化网络请求：</strong> 减小资源体积、合并请求、使用 CDN、启用 Gzip 压缩等都是优化网络请求的常见手段。确保合理使用缓存策略，尽量减少不必要的请求。</p></li><li><p><strong>资源压缩和混淆：</strong> 对代码、样式表和图片进行压缩，减小文件大小。对于 JavaScript 代码，可以进行混淆以减小文件体积。</p></li><li><p><strong>预加载和预渲染：</strong> 使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 标签预加载重要资源，以及考虑使用预渲染技术，提前生成页面的 HTML 和相关资源。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preload&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;example.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div></li><li><p><strong>使用骨架屏（Skeleton Screen）：</strong> 在页面加载时，先展示一个简单的骨架结构，再逐步填充内容。这可以提高用户的感知速度。</p></li><li><p><strong>延迟加载非关键性的组件：</strong> 将非首屏渲染的组件推迟到页面加载完成后再进行加载，不影响用户首屏体验。</p></li></ol><p>综合使用这些优化策略，可以有效减小 SPA 首屏加载慢的问题，提高用户体验。不同项目的情况各异，需要根据具体情况灵活应用这些策略。</p><h2 id="_13-vue-在双向数据绑定是如何实现的" tabindex="-1">13. Vue 在双向数据绑定是如何实现的？ <a class="header-anchor" href="#_13-vue-在双向数据绑定是如何实现的" aria-label="Permalink to &quot;13. Vue 在双向数据绑定是如何实现的？&quot;">​</a></h2><p>Vue.js 中的双向数据绑定是通过&quot;响应式系统&quot;和&quot;指令&quot;相结合的方式来实现的。</p><h3 id="_1-响应式系统" tabindex="-1">1. 响应式系统 <a class="header-anchor" href="#_1-响应式系统" aria-label="Permalink to &quot;1. 响应式系统&quot;">​</a></h3><p>Vue 通过使用“响应式系统”来追踪依赖关系，当依赖的数据发生变化时，自动触发更新。核心思想是利用 <code>Object.defineProperty</code> 或 <code>Proxy</code> 劫持对象的访问和修改，以便在数据变化时通知相关的观察者进行更新。</p><ul><li><p><strong>Object.defineProperty：</strong> 在 Vue 2.x 版本中，主要使用 <code>Object.defineProperty</code> 来实现数据的响应式。通过将对象的属性转化为 getter 和 setter，从而在获取和设置属性时执行相应的操作。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;property&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 读取数据时的操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 写入数据时的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 通知观察者更新</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    notify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p><strong>Proxy：</strong> 在 Vue 3.x 版本中，引入了 <code>Proxy</code> 作为替代方案，提供了更强大和灵活的对象代理能力，使得数据的监测更加直观和高效。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {},</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 读取数据时的操作</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target[key];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 写入数据时的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      target[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 通知观察者更新</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      notify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div></li></ul><h3 id="_2-指令" tabindex="-1">2. 指令 <a class="header-anchor" href="#_2-指令" aria-label="Permalink to &quot;2. 指令&quot;">​</a></h3><p>在 Vue 中，通过使用指令（如 <code>v-model</code>）来实现双向数据绑定。指令是一种特殊的语法糖，它使得 DOM 与数据之间建立了关联。</p><ul><li><p><strong>v-model 指令：</strong> 在表单元素上使用 <code>v-model</code> 指令可以实现双向数据绑定。<code>v-model</code> 实际上是一个语法糖，它会根据元素的类型自动处理不同的事件和属性。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>上述代码等价于：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;message&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;message = $event.target.value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div></li><li><p><strong>v-model 实现原理：</strong> <code>v-model</code> 通过在表单元素上监听 <code>input</code> 事件，以及绑定 <code>value</code> 属性来实现双向绑定。在背后，它是通过在 <code>input</code> 事件触发时将输入的值赋给绑定的数据。</p></li></ul><p>总体来说，Vue 的双向数据绑定是通过响应式系统追踪数据变化，以及通过指令处理视图与数据之间的关联来实现的。这使得开发者可以更便捷地处理用户输入和数据更新，提高了开发效率。</p><h2 id="_14-vue-组件中-data-为什么必须是一个函数" tabindex="-1">14. Vue 组件中 data 为什么必须是一个函数？ <a class="header-anchor" href="#_14-vue-组件中-data-为什么必须是一个函数" aria-label="Permalink to &quot;14. Vue 组件中 data 为什么必须是一个函数？&quot;">​</a></h2><p>在 Vue 组件中，<code>data</code> 为什么必须是一个函数的原因与 Vue 的设计理念和组件实例的复用有关。</p><h3 id="_1-组件实例的复用" tabindex="-1">1. 组件实例的复用 <a class="header-anchor" href="#_1-组件实例的复用" aria-label="Permalink to &quot;1. 组件实例的复用&quot;">​</a></h3><p>当一个组件被定义时，<code>data</code> 不是一个普通的对象，而是一个函数。这是因为 Vue 组件可以进行复用，多个组件实例可能会同时存在。如果 <code>data</code> 是一个普通对象，那么它将会变成共享的，一个组件的状态改变会影响到其他组件。</p><p>通过将 <code>data</code> 定义为一个函数，每次创建一个组件实例时，都会调用这个函数，返回一个新的数据对象，从而保证每个组件实例都有自己的数据对象，相互之间不会产生影响。</p><h3 id="_2-数据的响应式处理" tabindex="-1">2. 数据的响应式处理 <a class="header-anchor" href="#_2-数据的响应式处理" aria-label="Permalink to &quot;2. 数据的响应式处理&quot;">​</a></h3><p>Vue 通过响应式系统来追踪数据的变化，当 <code>data</code> 是一个函数时，Vue 能够更好地进行数据的监测和管理。如果 <code>data</code> 是一个普通的对象，Vue 将难以追踪到数据的变化。</p><p>函数形式的 <code>data</code> 允许 Vue 在组件实例化时为每个组件创建一个独立的数据对象，而不是共享一个引用。这样，当组件内的数据发生变化时，Vue 能够更准确地进行响应式更新。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 错误的写法，data是共享的</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 正确的写法，data是一个返回对象的函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>总之，将 <code>data</code> 设计为一个函数是为了保证每个组件实例都有独立的数据对象，防止数据共享导致的意外问题，并使得 Vue 能够更好地进行数据的响应式处理。</p><h2 id="_15-vue-跨域如何解决" tabindex="-1">15. Vue 跨域如何解决 <a class="header-anchor" href="#_15-vue-跨域如何解决" aria-label="Permalink to &quot;15. Vue 跨域如何解决&quot;">​</a></h2><p>在 Vue 中，跨域问题主要是由浏览器的同源策略（Same-Origin Policy）引起的。同源策略限制了在不同域名、协议或端口之间进行跨域访问。当你的 Vue 应用尝试从一个不同域的服务器请求数据时，可能会遇到跨域问题。</p><p>以下是一些解决 Vue 跨域问题的常见方法：</p><h3 id="_1-使用代理" tabindex="-1">1. 使用代理 <a class="header-anchor" href="#_1-使用代理" aria-label="Permalink to &quot;1. 使用代理&quot;">​</a></h3><p>在开发环境中，你可以配置一个代理服务器，将前端请求转发到后端 API 服务器，因为浏览器不会对同源策略对代理服务器产生影响。在 Vue 项目的 <code>config/index.js</code> 或 <code>vue.config.js</code> 中进行配置，设置代理规则。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  devServer: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    proxy: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;/api&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://api.example.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        changeOrigin: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pathRewrite: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          &quot;^/api&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>上述配置将 <code>/api</code> 下的请求代理到 <code>http://api.example.com</code>。</p><h3 id="_2-jsonp-请求" tabindex="-1">2. JSONP 请求 <a class="header-anchor" href="#_2-jsonp-请求" aria-label="Permalink to &quot;2. JSONP 请求&quot;">​</a></h3><p>如果后端支持 JSONP，你可以通过在 Vue 中使用 JSONP 库（如 <code>jsonp</code> 库）进行跨域请求。JSONP 是一种通过动态创建 <code>script</code> 标签的方式来绕过同源策略的方法。</p><h3 id="_3-cors-跨域资源共享" tabindex="-1">3. CORS（跨域资源共享） <a class="header-anchor" href="#_3-cors-跨域资源共享" aria-label="Permalink to &quot;3. CORS（跨域资源共享）&quot;">​</a></h3><p>如果后端支持 CORS，确保后端 API 服务器正确配置 CORS 头信息，以允许特定域的请求。在 Vue 中不需要特别的配置，浏览器会根据服务器的 CORS 配置进行处理。</p><h3 id="_4-使用反向代理-nginx" tabindex="-1">4. 使用反向代理（Nginx） <a class="header-anchor" href="#_4-使用反向代理-nginx" aria-label="Permalink to &quot;4. 使用反向代理（Nginx）&quot;">​</a></h3><p>部署时，可以考虑在服务器上配置反向代理，将 Vue 应用和 API 服务器部署在同一域下。</p><h3 id="_5-修改后端服务器配置" tabindex="-1">5. 修改后端服务器配置 <a class="header-anchor" href="#_5-修改后端服务器配置" aria-label="Permalink to &quot;5. 修改后端服务器配置&quot;">​</a></h3><p>在后端服务器中配置响应头，允许特定的域进行跨域访问。这需要后端的支持。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在Express中设置CORS</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> express</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;express&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> app</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> express</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Access-Control-Allow-Origin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 允许所有域访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Access-Control-Allow-Methods&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;GET, POST, OPTIONS, PUT, PATCH, DELETE&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Access-Control-Allow-Headers&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Content-Type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 其他路由处理</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span></code></pre></div><p>选择哪种方法取决于具体的场景和后端的支持情况。需要注意，一些解决方案可能会涉及到安全性和性能方面的考虑，因此在生产环境中需要谨慎选择合适的解决方案。</p><h2 id="_16-谈谈你对-nexttick-的理解-并说出应用场景" tabindex="-1">16. 谈谈你对 $nextTick 的理解，并说出应用场景 <a class="header-anchor" href="#_16-谈谈你对-nexttick-的理解-并说出应用场景" aria-label="Permalink to &quot;16. 谈谈你对 $nextTick 的理解，并说出应用场景&quot;">​</a></h2><p><code>$nextTick</code> 是 Vue.js 提供的一个异步操作方法，用于在 DOM 更新之后执行回调函数。这个方法主要用于获取 Vue 更新后的 DOM 状态，确保在 DOM 更新完成后再执行某些操作。它接受一个回调函数作为参数，在下次 DOM 更新循环结束之后执行。</p><h3 id="主要作用" tabindex="-1">主要作用 <a class="header-anchor" href="#主要作用" aria-label="Permalink to &quot;主要作用&quot;">​</a></h3><ol><li><p><strong>DOM 更新后的操作：</strong> 在 Vue 中，数据的变化会触发视图的更新，但是这个更新是异步的，不会立即反映在 DOM 上。如果需要在更新后对 DOM 进行操作，可以使用 <code>$nextTick</code> 来确保在下次 DOM 更新循环结束后执行。</p></li><li><p><strong>解决异步更新的问题：</strong> 在某些情况下，Vue 中的数据变化可能不会立即生效，而是在下一个事件循环中生效。这时如果需要获取到更新后的 DOM 状态，就需要使用 <code>$nextTick</code>。</p></li></ol><h3 id="应用场景-1" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景-1" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><ol><li><p><strong>操作更新后的 DOM 元素：</strong> 在模板中使用 <code>v-if</code>、<code>v-show</code>、<code>v-for</code> 等指令动态渲染元素时，需要在更新后操作新渲染出来的元素。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;showMessage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ message }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;toggleMessage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Toggle Message&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        showMessage: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        message: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, Vue!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      toggleMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.showMessage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.showMessage;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 此时获取的DOM可能还没有更新，需要使用$nextTick确保在DOM更新后执行</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;DOM updated:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$el.textContent);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>操作渲染列表后的元素：</strong> 在使用 <code>v-for</code> 渲染列表时，如果需要在列表更新后获取到新渲染的元素，也可以使用 <code>$nextTick</code>。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item in items&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;item.id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ item.name }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        items: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          { id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Item 1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          { id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Item 2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          { id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Item 3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      addItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 更新数据</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Item 4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 此时获取的DOM可能还没有更新，需要使用$nextTick确保在DOM更新后执行</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;New item added:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$el.textContent);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li></ol><p>总的来说，<code>$nextTick</code> 在需要在 Vue 更新后执行一些操作时非常有用，特别是涉及到动态渲染、条件渲染、列表渲染等场景。</p><h2 id="_17-v-if-和-v-show-有什么区别" tabindex="-1">17. v-if 和 v-show 有什么区别 <a class="header-anchor" href="#_17-v-if-和-v-show-有什么区别" aria-label="Permalink to &quot;17. v-if 和 v-show 有什么区别&quot;">​</a></h2><p><code>v-if</code> 和 <code>v-show</code> 是 Vue 中用于条件渲染的两个指令，它们在使用上有一些区别。</p><h3 id="v-if" tabindex="-1">v-if <a class="header-anchor" href="#v-if" aria-label="Permalink to &quot;v-if&quot;">​</a></h3><ol><li><p><strong>懒加载：</strong> <code>v-if</code> 是“惰性”的，即当条件为假时，元素及其子组件不会被渲染到 DOM 中。只有当条件为真时，元素才会被动态添加到 DOM 中。</p></li><li><p><strong>性能开销：</strong> 由于 <code>v-if</code> 是惰性的，当条件为假时，该元素及其子组件的生命周期钩子函数和事件监听器都不会被触发，因此可以在某些场景下带来性能的提升。</p></li><li><p><strong>切换开销：</strong> 在条件切换时，<code>v-if</code> 会销毁和重建条件块内的所有元素及其子组件，可能会引起性能开销，特别是在条件块内有复杂的组件树时。</p></li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;isTrue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;This is true!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="v-show" tabindex="-1">v-show <a class="header-anchor" href="#v-show" aria-label="Permalink to &quot;v-show&quot;">​</a></h3><ol><li><p><strong>一直存在于 DOM 中：</strong> <code>v-show</code> 不会改变元素的实际显示状态，而是通过 CSS 的 <code>display</code> 属性控制元素的显示与隐藏。即使条件为假，元素仍然存在于 DOM 中。</p></li><li><p><strong>性能开销：</strong> <code>v-show</code> 在条件为假时，元素的生命周期钩子函数和事件监听器仍然会被执行，所以在某些场景下可能有一些性能开销。</p></li><li><p><strong>切换开销：</strong> 在条件切换时，<code>v-show</code> 只是切换元素的 <code>display</code> 样式，不会销毁和重建元素及其子组件，相对于 <code>v-if</code>，在条件切换时的性能开销较小。</p></li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;isTrue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;This is true!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="如何选择-1" tabindex="-1">如何选择 <a class="header-anchor" href="#如何选择-1" aria-label="Permalink to &quot;如何选择&quot;">​</a></h3><ul><li><p>如果在页面渲染过程中，元素的显示与隐藏频繁切换，并且在切换时元素内部有复杂的组件树，推荐使用 <code>v-show</code>，因为它的切换开销较小。</p></li><li><p>如果元素在大部分时间都是隐藏的，并且在切换时元素内部的组件树比较庞大，推荐使用 <code>v-if</code>，因为它可以在条件为假时不渲染元素及其子组件，提高性能。</p></li></ul><p>综上所述，选择 <code>v-if</code> 还是 <code>v-show</code> 取决于具体的使用场景和性能需求。</p><h2 id="_18-for-循环的时候为什么用-key" tabindex="-1">18. for 循环的时候为什么用 key <a class="header-anchor" href="#_18-for-循环的时候为什么用-key" aria-label="Permalink to &quot;18. for 循环的时候为什么用 key&quot;">​</a></h2><p>在 Vue 中，使用 <code>v-for</code> 进行循环渲染时，通常需要为每个项指定一个唯一的 <code>key</code> 属性。这个 <code>key</code> 的主要作用是帮助 Vue 识别每个节点的唯一性，以便更高效地进行 DOM 更新。</p><h3 id="主要原因" tabindex="-1">主要原因 <a class="header-anchor" href="#主要原因" aria-label="Permalink to &quot;主要原因&quot;">​</a></h3><ol><li><p><strong>提高性能：</strong> 使用 <code>key</code> 可以帮助 Vue 进行更高效的虚拟 DOM 的 diff 算法。通过 <code>key</code>，Vue 能够追踪每个节点的变化，减少不必要的 DOM 操作，提高性能。</p></li><li><p><strong>维持组件状态：</strong> 当列表中的项发生变化时，Vue 会根据 <code>key</code> 的变化判断是更新现有元素、添加新元素，还是移除不存在的元素。这样可以保持组件的状态，避免不必要的销毁和重新创建，提高页面的渲染效率。</p></li></ol><h3 id="具体作用" tabindex="-1">具体作用 <a class="header-anchor" href="#具体作用" aria-label="Permalink to &quot;具体作用&quot;">​</a></h3><ol><li><p><strong>唯一标识：</strong> <code>key</code> 作为每个循环项的唯一标识，确保每个项在 Vue 的虚拟 DOM 中都有一个唯一的标识。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(item, index) in items&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ item.name }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>动态更新：</strong> 当数据变化时，Vue 会根据 <code>key</code> 的变化，精准地更新页面上对应的元素，而不是简单地重新渲染整个列表。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改数据时，Vue 根据 key 的变化，精确地更新对应元素</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">splice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Updated Item&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div></li><li><p><strong>保持状态：</strong> 如果不使用 <code>key</code>，Vue 可能会将原先的节点认为是相同的节点，导致错误的更新或重新渲染。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不使用 key，可能会导致错误的更新或重新渲染</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">splice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Updated Item&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div></li></ol><p>总之，为 <code>v-for</code> 循环中的每个项指定一个唯一的 <code>key</code> 是为了提高性能、更精确地更新页面、以及保持组件状态的一种重要手段。在开发中，尽量选择具有唯一标识的属性作为 <code>key</code>，以确保准确性和性能。避免使用索引作为 <code>key</code>，特别是当列表项可能会发生顺序变化时。</p><h2 id="_19-路由跳转传参的方式有哪些-分别怎么使用的" tabindex="-1">19. 路由跳转传参的方式有哪些？分别怎么使用的？ <a class="header-anchor" href="#_19-路由跳转传参的方式有哪些-分别怎么使用的" aria-label="Permalink to &quot;19. 路由跳转传参的方式有哪些？分别怎么使用的？&quot;">​</a></h2><p>在 Vue 中，路由跳转传参有多种方式，以下是一些常见的方法：</p><h3 id="_1-动态路由参数" tabindex="-1">1. 动态路由参数 <a class="header-anchor" href="#_1-动态路由参数" aria-label="Permalink to &quot;1. 动态路由参数&quot;">​</a></h3><p>动态路由参数是将参数直接包含在路由路径中。在路由定义时使用冒号 <code>:</code> 定义参数，然后通过 <code>$route.params</code> 来获取参数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 路由定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/user/:id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: User</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 跳转</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/user/123&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在组件中获取参数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$route.params.id </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 123</span></span></code></pre></div><h3 id="_2-查询参数" tabindex="-1">2. 查询参数 <a class="header-anchor" href="#_2-查询参数" aria-label="Permalink to &quot;2. 查询参数&quot;">​</a></h3><p>查询参数是将参数以键值对的形式附加在 URL 后面，使用 <code>$route.query</code> 来获取参数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 路由定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/user&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: User</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 跳转</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/user&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, query: { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;123&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在组件中获取参数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$route.query.id </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 123</span></span></code></pre></div><h3 id="_3-命名路由" tabindex="-1">3. 命名路由 <a class="header-anchor" href="#_3-命名路由" aria-label="Permalink to &quot;3. 命名路由&quot;">​</a></h3><p>在命名路由中传递参数，使用 <code>$router.push</code> 时，可以通过 <code>params</code> 或 <code>query</code> 来传递参数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 路由定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;user&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/user/:id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: User</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 跳转，通过 params 传递</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;user&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, params: { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;123&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 跳转，通过 query 传递</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;user&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, query: { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;123&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在组件中获取参数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$route.params.id </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 123</span></span></code></pre></div><h3 id="_4-路由元信息" tabindex="-1">4. 路由元信息 <a class="header-anchor" href="#_4-路由元信息" aria-label="Permalink to &quot;4. 路由元信息&quot;">​</a></h3><p>可以通过路由的元信息（<code>meta</code>）传递参数，这种方式适用于需要在路由级别传递一些静态信息的情况。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 路由定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/user&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: User,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;123&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在组件中获取参数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$route.meta.id </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 123</span></span></code></pre></div><h3 id="_5-状态管理" tabindex="-1">5. 状态管理 <a class="header-anchor" href="#_5-状态管理" aria-label="Permalink to &quot;5. 状态管理&quot;">​</a></h3><p>使用状态管理工具（如 Vuex）来进行参数的状态管理，通过在状态管理中存储和获取参数。</p><p>这些方式可以根据实际需求选择，通常来说，动态路由参数适用于路径参数比较固定的情况，查询参数适用于灵活的传递参数，命名路由适用于需要在不同组件之间传递参数的情况，而路由元信息适用于需要在全局或页面级别传递静态信息的情况，而状态管理则适用于更大范围的状态共享。</p><h2 id="_20-options-api-与-composition-api-的区别" tabindex="-1">20. Options API 与 Composition API 的区别？ <a class="header-anchor" href="#_20-options-api-与-composition-api-的区别" aria-label="Permalink to &quot;20. Options API 与 Composition API 的区别？&quot;">​</a></h2><p>Vue.js 2.x 使用的是 Options API，而在 Vue.js 3.x 中引入了 Composition API。两者在代码组织、逻辑复用和响应性等方面有一些区别。</p><h3 id="options-api" tabindex="-1">Options API <a class="header-anchor" href="#options-api" aria-label="Permalink to &quot;Options API&quot;">​</a></h3><ol><li><p><strong>分离选项：</strong> 使用 Options API 时，一个组件的选项（data、methods、computed、watch 等）是分离的，这意味着相关的逻辑可能会分散在不同的选项中，导致组件变得较为复杂。</p></li><li><p><strong>this 上下文：</strong> 在 Options API 中，组件内的 <code>this</code> 上下文指向组件实例，访问数据和方法直接通过 <code>this</code> 进行。</p></li><li><p><strong>逻辑复用：</strong> 逻辑复用需要使用混入（Mixin）来实现，这可能会导致命名冲突、组件较为松散的结构。</p></li></ol><h3 id="composition-api" tabindex="-1">Composition API <a class="header-anchor" href="#composition-api" aria-label="Permalink to &quot;Composition API&quot;">​</a></h3><ol><li><p><strong>组合逻辑：</strong> Composition API 引入了 <code>setup</code> 函数，将组件的逻辑组合在一个函数中，使得相关逻辑可以更紧凑地组织在一起，提高代码的可读性和维护性。</p></li><li><p><strong>使用响应式 API：</strong> Composition API 提供了新的响应式 API（<code>ref</code>、<code>reactive</code> 等），更加灵活且直观，能够更方便地处理组件的响应式数据。</p></li><li><p><strong>解决 this 上下文问题：</strong> 在 Composition API 中，不再需要使用 <code>this</code>，而是通过 <code>ref</code>、<code>reactive</code> 等函数来创建响应式数据，使得在组件逻辑中不再依赖于 <code>this</code> 上下文。</p></li><li><p><strong>逻辑复用：</strong> 使用 Composition API 可以更容易地实现逻辑的复用，通过提供更多的工具函数，使得组合逻辑更加灵活。</p></li></ol><h3 id="选择使用场景" tabindex="-1">选择使用场景 <a class="header-anchor" href="#选择使用场景" aria-label="Permalink to &quot;选择使用场景&quot;">​</a></h3><ul><li><p><strong>Options API：</strong> 在小型项目或者你对 Composition API 不太熟悉时，Options API 是一个简单且直观的选择，它已经被广泛应用于 Vue 2.x。</p></li><li><p><strong>Composition API：</strong> 在大型项目或者需要更好的组织代码结构、逻辑复用和响应式处理时，可以考虑使用 Composition API。它使得代码更加清晰，提供了更多的工具函数，能够更好地处理复杂的逻辑和状态管理。</p></li></ul><p>需要注意的是，Vue 3.x 同时支持 Options API 和 Composition API，你可以根据项目的需求选择使用其中之一或混合使用。</p><h2 id="_21-怎样理解-vue-的单项数据流" tabindex="-1">21. 怎样理解 Vue 的单项数据流 <a class="header-anchor" href="#_21-怎样理解-vue-的单项数据流" aria-label="Permalink to &quot;21. 怎样理解 Vue 的单项数据流&quot;">​</a></h2><p>Vue 的单向数据流是指数据在应用中的流动方向是单一的，即从父组件传递到子组件。这个概念是 Vue 框架的核心之一，它带来了一些重要的特性和优势。</p><h3 id="主要理解点" tabindex="-1">主要理解点： <a class="header-anchor" href="#主要理解点" aria-label="Permalink to &quot;主要理解点：&quot;">​</a></h3><ol><li><p><strong>父子组件关系：</strong> 在 Vue 中，父组件可以通过属性（props）向子组件传递数据。子组件不能直接修改父组件的数据，而是通过触发事件来告知父组件需要修改数据。</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 父组件 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">child-component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parentMessage</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">updateMessage</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ChildComponent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./ChildComponent.vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      parentMessage: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello from parent!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  components: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ChildComponent,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updateMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.parentMessage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newMessage;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 子组件 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ message }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">changeMessage</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Change Message&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    changeMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;updateMessage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;New message from child!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>数据的单向流动：</strong> 数据的流动方向是单一的，从父组件到子组件。这有助于更好地追踪数据的变化和状态的管理，减少了出现意外行为的可能性。</p></li><li><p><strong>易于调试和理解：</strong> 单向数据流使得组件之间的关系清晰，易于理解和调试。每个组件都有明确的数据来源，便于追踪数据的变化和调试代码。</p></li><li><p><strong>组件的独立性：</strong> 子组件的状态和行为更加独立，可以更容易地复用和维护。父组件和子组件之间通过 props 和 events 进行通信，降低了组件之间的耦合性。</p></li></ol><p>总体来说，Vue 的单向数据流是为了提高代码的可维护性、可读性以及降低程序出错的可能性。这一特性是 Vue 框架的设计哲学之一，有助于构建更健壮的应用。</p><h2 id="_22-路由-说出嵌套路由-命名视图的场景" tabindex="-1">22. 路由-说出嵌套路由&amp;命名视图的场景 <a class="header-anchor" href="#_22-路由-说出嵌套路由-命名视图的场景" aria-label="Permalink to &quot;22. 路由-说出嵌套路由&amp;命名视图的场景&quot;">​</a></h2><p>在 Vue Router 中，嵌套路由和命名视图是两个强大的概念，它们可以用于更灵活和复杂的路由结构。</p><h3 id="_1-嵌套路由-nested-routes" tabindex="-1">1. 嵌套路由 (Nested Routes) <a class="header-anchor" href="#_1-嵌套路由-nested-routes" aria-label="Permalink to &quot;1. 嵌套路由 (Nested Routes)&quot;">​</a></h3><p>嵌套路由是指在一个路由下定义的子路由，它们可以形成层级关系。嵌套路由常用于构建复杂的页面结构，其中某个路由下有多个子路由。</p><h4 id="场景" tabindex="-1">场景： <a class="header-anchor" href="#场景" aria-label="Permalink to &quot;场景：&quot;">​</a></h4><ol><li><p><strong>管理面板：</strong> 在管理面板中，可以使用嵌套路由来组织不同模块或功能的子页面。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/admin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      component: AdminLayout,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      children: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        { path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dashboard&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: Dashboard },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        { path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;users&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: Users },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        { path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;settings&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: Settings },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p><strong>文章详情页：</strong> 对于博客应用，可以使用嵌套路由来显示文章列表和单篇文章详情。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/blog&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      component: BlogLayout,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      children: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        { path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;posts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: PostList },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        { path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;posts/:id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: PostDetail },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ol><h3 id="_2-命名视图-named-views" tabindex="-1">2. 命名视图 (Named Views) <a class="header-anchor" href="#_2-命名视图-named-views" aria-label="Permalink to &quot;2. 命名视图 (Named Views)&quot;">​</a></h3><p>命名视图是指在同一路由组件中使用多个 <code>router-view</code> 来显示不同的组件。每个 <code>router-view</code> 都通过 <code>name</code> 属性指定对应的组件。</p><h4 id="场景-1" tabindex="-1">场景： <a class="header-anchor" href="#场景-1" aria-label="Permalink to &quot;场景：&quot;">​</a></h4><ol><li><p><strong>复杂页面布局：</strong> 当页面布局比较复杂，需要同时展示多个独立的组件时，可以使用命名视图来达到灵活的布局效果。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      components: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        header: Header,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sidebar: Sidebar,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        default: MainContent,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        footer: Footer,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li><li><p><strong>多个同级路由：</strong> 当存在多个同级路由，每个路由需要显示在不同的区域时，可以使用命名视图。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/dashboard&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      components: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        default: Dashboard,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sidebar: DashboardSidebar,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        header: DashboardHeader,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/profile&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      components: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        default: UserProfile,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        sidebar: ProfileSidebar,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        header: ProfileHeader,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div></li></ol><p>使用嵌套路由和命名视图可以使得路由的管理更加灵活，能够适应不同场景下的复杂页面结构和布局需求。</p>`,214)],o=s(l,[["render",function(h,p,e,k,E,r){return a(),i("div",null,t)}]]);export{g as __pageData,o as default};
