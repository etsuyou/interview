import{_ as s,D as i,c as e,I as l,a4 as t,o as n}from"./chunks/framework.B2xMVIVo.js";const E=JSON.parse('{"title":"认识Web和Web标准","description":"","frontmatter":{"title":"认识Web和Web标准","publish":false},"headers":[],"relativePath":"tutorial/03-CSS进阶/CSS面试题.md","filePath":"tutorial/03-CSS进阶/CSS面试题.md","lastUpdated":1718865103000}'),h={name:"tutorial/03-CSS进阶/CSS面试题.md"},p=t(`<h1 id="认识-web-和-web-标准" tabindex="-1">认识 Web 和 Web 标准 <a class="header-anchor" href="#认识-web-和-web-标准" aria-label="Permalink to &quot;认识 Web 和 Web 标准&quot;">​</a></h1><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h2><h3 id="你是如何理解-html-语义化的" tabindex="-1">你是如何理解 HTML 语义化的？ <a class="header-anchor" href="#你是如何理解-html-语义化的" aria-label="Permalink to &quot;你是如何理解 HTML 语义化的？&quot;">​</a></h3><p><strong>语义化</strong>：指对文本内容的结构化（内容语义化），选择合乎语义的标签（代码语义化）。</p><p><strong>举例</strong>：段落用 p，边栏用 aside，主要内容用 main 标签。</p><p><strong>好处：</strong></p><ul><li><p>便于开发者阅读和维护</p></li><li><p>有利于 SEO：让浏览器的爬虫和辅助技术更好的解析，</p></li></ul><p><strong>语义化标签介绍</strong>：</p><p>在 HTML5 出来之前，我们习惯于用 div 来表示页面的章节或者不同模块，但是<code>div</code>本身是没有语义的。但是现在，HTML5 中加入了一些语义化标签，来更清晰的表达文档结构。</p><p>20180322_1120.jpg</p><p>参考链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/32570423" target="_blank" rel="noreferrer">初探 · HTML5 语义化</a></li></ul><h3 id="meta-viewport-是做什么用的-怎么写" tabindex="-1">meta viewport 是做什么用的，怎么写？ <a class="header-anchor" href="#meta-viewport-是做什么用的-怎么写" aria-label="Permalink to &quot;meta viewport 是做什么用的，怎么写？&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><p>控制页面在移动端不要缩小显示。</p><h3 id="canvas-元素是干什么的" tabindex="-1">canvas 元素是干什么的？ <a class="header-anchor" href="#canvas-元素是干什么的" aria-label="Permalink to &quot;canvas 元素是干什么的？&quot;">​</a></h3><p>看 MDN 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noreferrer">canvas 入门手册</a>。</p><h3 id="说一下-css-盒模型" tabindex="-1">说一下 CSS 盒模型 <a class="header-anchor" href="#说一下-css-盒模型" aria-label="Permalink to &quot;说一下 CSS 盒模型&quot;">​</a></h3><p>可以参考本人的另外一篇文章：《02-CSS 基础/06-CSS 盒模型详解》。</p><h3 id="css-reset-和-normalize-css-有什么区别" tabindex="-1">css reset 和 Normalize.css 有什么区别 <a class="header-anchor" href="#css-reset-和-normalize-css-有什么区别" aria-label="Permalink to &quot;css reset 和 Normalize.css 有什么区别&quot;">​</a></h3><blockquote><p>此题考英文。</p></blockquote><p>二者都是用来<strong>统一</strong>浏览器的默认样式：</p><ul><li><p>reset：重置。相对「暴力」，不管你有没有用，统统重置成一样的效果，且影响的范围很大，讲求跨浏览器的一致性。（一刀切）</p></li><li><p><code>Normalize.css</code> ：标准化。相对「平和」，注重通用的方案，重置掉该重置的样式，保留有用的 user agent 样式，同时进行一些 bug 的修复，这点是 reset 所缺乏的。（去伪存真）</p></li></ul><p>参考链接：</p><ul><li><p><a href="https://p.baidu.com/question/ab496162636234613761335c00" target="_blank" rel="noreferrer">Normalize.css 与传统的 CSS Reset 有哪些区别？</a></p></li><li><p><a href="http://www.bbsxiaomi.com/html_css/html5_css3/177.html" target="_blank" rel="noreferrer">CSS3 初始化代码 Normalize.css 中文版</a></p></li><li><p><a href="https://github.com/chokcoco/iCSS" target="_blank" rel="noreferrer">谈谈一些有趣的 CSS 话题</a></p></li><li><p><a href="https://segmentfault.com/a/1190000006890725" target="_blank" rel="noreferrer">前端面试之 CSS 总结(上)</a></p></li></ul><h3 id="选择器的优先级如何确定" tabindex="-1">选择器的优先级如何确定 <a class="header-anchor" href="#选择器的优先级如何确定" aria-label="Permalink to &quot;选择器的优先级如何确定&quot;">​</a></h3><ul><li><p>选择器越具体，优先级越高。 #xxx 大于 .yyy</p></li><li><p>同样优先级，写在后面的覆盖前面的。</p></li><li><p>color: red !important; 优先级最高。</p></li></ul><h3 id="bfc-是什么" tabindex="-1">BFC 是什么 <a class="header-anchor" href="#bfc-是什么" aria-label="Permalink to &quot;BFC 是什么&quot;">​</a></h3><p>overflow:hidden ：取消父子 margin 合并。 （另一种推荐做法：<code>padding-top: 0.1px;</code>）</p><h3 id="如何清除浮动" tabindex="-1">如何清除浮动 <a class="header-anchor" href="#如何清除浮动" aria-label="Permalink to &quot;如何清除浮动&quot;">​</a></h3><p>（1）overflow: hidden</p><p>（2）.clearfix 清除浮动写在爸爸身上</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfix::after</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">block</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  clear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">both</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 兼容 IE */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.clearfix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  zoom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="伪类和伪元素的区别是什么" tabindex="-1">伪类和伪元素的区别是什么？ <a class="header-anchor" href="#伪类和伪元素的区别是什么" aria-label="Permalink to &quot;伪类和伪元素的区别是什么？&quot;">​</a></h3><p>概念上的区别：</p><ul><li><p>伪类表示一种状态</p></li><li><p>伪元素是真的有元素。比如 ::after 是真的有元素，可以在页面上显示内容。</p></li></ul><p>使用上的区别：</p><ul><li><p>伪类：使用单冒号</p></li><li><p>伪元素：使用双冒号</p></li></ul><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/33998813" target="_blank" rel="noreferrer">互联网公司招聘启事的正确阅读方式</a></li></ul>`,40),b=s(h,[["render",function(r,o,k,d,c,u){const a=i("ArticleTopAd");return n(),e("div",null,[l(a),p])}]]);export{E as __pageData,b as default};
